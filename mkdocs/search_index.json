{
    "docs": [
        {
            "location": "/",
            "text": "zend-di\n\n\n\n\n\n\nZend\\Di\n is an example of an Inversion of Control (IoC) container. IoC containers\nare widely used to create object instances that have all dependencies resolved\nand injected. Dependency Injection containers are one form of IoC \u2013 but not the\nonly form.\n\n\n\n\nFile issues at https://github.com/zendframework/zend-di/issues\n\n\nDocumentation is at https://zendframework.github.io/zend-di/",
            "title": "Home"
        },
        {
            "location": "/#zend-di",
            "text": "Zend\\Di  is an example of an Inversion of Control (IoC) container. IoC containers\nare widely used to create object instances that have all dependencies resolved\nand injected. Dependency Injection containers are one form of IoC \u2013 but not the\nonly form.   File issues at https://github.com/zendframework/zend-di/issues  Documentation is at https://zendframework.github.io/zend-di/",
            "title": "zend-di"
        },
        {
            "location": "/intro/",
            "text": "Introduction\n\n\nDependency Injection\n\n\nDependency Injection (here-in called DI) refers to the act of providing\ndependencies for an object during instantiation or via a method call. A basic\nexample looks like this:\n\n\n$b = new MovieLister(new MovieFinder());\n\n\n\n\nAbove, \nMovieFinder\n is a dependency of \nMovieLister\n, and \nMovieFinder\n was\ninjected into \nMovieLister\n.\n\n\nIf\nyou are not familiar with the concept of DI, here are a couple of great reads:\n\n\n\n\nMatthew Weier O'Phinney's Analogy\n\n\nRalph Schindler's Learning DI\n\n\nFabien Potencier's Series\n on DI\n\n\n\n\n\n\nzend-servicemanager\n\n\nZend\\Di\n is an example of an Inversion of Control (IoC) container. IoC containers are widely used\nto create object instances that have all dependencies resolved and injected. Dependency Injection\ncontainers are one form of IoC, but not the only form.\n\n\nZend Framework ships with another form of IoC as well,\n\nzend-servicemanager\n.\nUnlike zend-di, zend-servicemanager is code-driven, meaning that you tell it\nwhat class to instantiate, or provide a factory for the given class. This\napproach offers several benefits:\n\n\n\n\nEasier to debug (error stacks take you into your factories, not the\n  dependency injection container).\n\n\nEasier to setup (write code to instantiate objects, instead of\n  configuration).\n\n\nFaster (zend-di has known performance issues due to the approaches used).\n\n\n\n\nUnless you have specific needs for a dependency injection container versus\nmore general Inversion of Control, we recommend using zend-servicemanager for\nthe above reasons.\n\n\n\n\nDependency Injection Containers\n\n\nWhen your code is written in such a way that all your dependencies are injected\ninto consuming objects, you might find that the simple act of wiring an object\nhas gotten more complex. When this becomes the case, and you find that this\nwiring is creating more boilerplate code, this makes for an excellent\nopportunity to utilize a Dependency Injection Container.\n\n\nIn it's simplest form, a Dependency Injection Container (here-in called a DiC\nfor brevity), is an object that is capable of creating objects on request and\nmanaging the \"wiring\", or the injection of required dependencies, for those\nrequested objects. Since the patterns that developers employ in writing DI\ncapable code vary, DiC's are generally either in the form of smallish objects\nthat suit a very specific pattern, or larger DiC frameworks.\n\n\nzend-di is a DiC framework. While for the simplest code there is no\nconfiguration needed, and the use cases are quite simple, zend-di is capable of\nbeing configured to wire these complex use cases",
            "title": "Intro"
        },
        {
            "location": "/intro/#introduction",
            "text": "",
            "title": "Introduction"
        },
        {
            "location": "/intro/#dependency-injection",
            "text": "Dependency Injection (here-in called DI) refers to the act of providing\ndependencies for an object during instantiation or via a method call. A basic\nexample looks like this:  $b = new MovieLister(new MovieFinder());  Above,  MovieFinder  is a dependency of  MovieLister , and  MovieFinder  was\ninjected into  MovieLister .  If\nyou are not familiar with the concept of DI, here are a couple of great reads:   Matthew Weier O'Phinney's Analogy  Ralph Schindler's Learning DI  Fabien Potencier's Series  on DI",
            "title": "Dependency Injection"
        },
        {
            "location": "/intro/#zend-servicemanager",
            "text": "Zend\\Di  is an example of an Inversion of Control (IoC) container. IoC containers are widely used\nto create object instances that have all dependencies resolved and injected. Dependency Injection\ncontainers are one form of IoC, but not the only form.  Zend Framework ships with another form of IoC as well, zend-servicemanager .\nUnlike zend-di, zend-servicemanager is code-driven, meaning that you tell it\nwhat class to instantiate, or provide a factory for the given class. This\napproach offers several benefits:   Easier to debug (error stacks take you into your factories, not the\n  dependency injection container).  Easier to setup (write code to instantiate objects, instead of\n  configuration).  Faster (zend-di has known performance issues due to the approaches used).   Unless you have specific needs for a dependency injection container versus\nmore general Inversion of Control, we recommend using zend-servicemanager for\nthe above reasons.",
            "title": "zend-servicemanager"
        },
        {
            "location": "/intro/#dependency-injection-containers",
            "text": "When your code is written in such a way that all your dependencies are injected\ninto consuming objects, you might find that the simple act of wiring an object\nhas gotten more complex. When this becomes the case, and you find that this\nwiring is creating more boilerplate code, this makes for an excellent\nopportunity to utilize a Dependency Injection Container.  In it's simplest form, a Dependency Injection Container (here-in called a DiC\nfor brevity), is an object that is capable of creating objects on request and\nmanaging the \"wiring\", or the injection of required dependencies, for those\nrequested objects. Since the patterns that developers employ in writing DI\ncapable code vary, DiC's are generally either in the form of smallish objects\nthat suit a very specific pattern, or larger DiC frameworks.  zend-di is a DiC framework. While for the simplest code there is no\nconfiguration needed, and the use cases are quite simple, zend-di is capable of\nbeing configured to wire these complex use cases",
            "title": "Dependency Injection Containers"
        },
        {
            "location": "/quick-start/",
            "text": "Quick Start\n\n\nThis quick start is intended to get developers familiar with the concepts of the\nzend-di DiC.  Generally speaking, code is never as simple as it is inside this\nexample, so working knowledge of the other sections of the manual is suggested.\n\n\nAssume, for a moment, the following application code. It already assumes that\ndependencies are injected, and so becomes a good candiate for a DiC.\n\n\nnamespace MyLibrary\n{\n    class DbAdapter\n    {\n        protected $username = null;\n        protected $password = null;\n\n        public function __construct($username, $password)\n        {\n            $this->username = $username;\n            $this->password = $password;\n        }\n    }\n}\n\nnamespace MyMovieApp\n{\n    class MovieFinder\n    {\n        protected $dbAdapter = null;\n\n        public function __construct(\\MyLibrary\\DbAdapter $dbAdapter)\n        {\n            $this->dbAdapter = $dbAdapter;\n        }\n    }\n\n    class MovieLister\n    {\n        protected $movieFinder = null;\n\n        public function __construct(MovieFinder $movieFinder)\n        {\n            $this->movieFinder = $movieFinder;\n        }\n    }\n}\n\n\n\n\nWith the above code, you find yourself writing the following to wire and utilize\nit:\n\n\n// $config object is assumed\n\n$dbAdapter = new MyLibrary\\DbAdapter($config->username, $config->password);\n$movieFinder = new MyMovieApp\\MovieFinder($dbAdapter);\n$movieLister = new MyMovieApp\\MovieLister($movieFinder);\nforeach ($movieLister as $movie) {\n    // iterate and display $movie\n}\n\n\n\n\nIf you are doing this above wiring in each controller or view that wants to list\nmovies, not only can this become repetitive and boring to write, but also\nunmaintainable if you want to swap out one of these dependencies on a wholesale\nscale.\n\n\nSince this example of code already practices good dependency injection using\nconstructor injection, it is a great candidate for using zend-di.\n\n\nThe following demonstrates how to wire the above into a zend-di container:\n\n\n// Inside a bootstrap somewhere\n$di = new Zend\\Di\\Di();\n$di->instanceManager()->setParameters('MyLibrary\\DbAdapter', [\n    'username' => $config->username,\n    'password' => $config->password,\n]);\n\n// Elsewhere:\n$movieLister = $di->get('MyMovieApp\\MovieLister');\nforeach ($movieLister as $movie) {\n    // iterate and display $movie\n}\n\n\n\n\nIn the above example, we are obtaining a \ndefault instance\n of \nZend\\Di\\Di\n. By\n'default', we mean that \nZend\\\\Di\\\\Di\n is constructed with a \nDefinitionList\n\nseeded with a \nRuntimeDefinition\n (which uses PHP's Reflection API) and an empty\ninstance manager and no configuration:\n\n\npublic function __construct(\n    DefinitionList $definitions = null,\n    InstanceManager $instanceManager = null,\n    Configuration $config = null\n) {\n    $this->definitions = ($definitions) ?: new DefinitionList(new Definition\\RuntimeDefinition());\n    $this->instanceManager = ($instanceManager) ?: new InstanceManager();\n\n    if ($config) {\n        $this->configure($config);\n    }\n}\n\n\n\n\nThis means that when \n$di->get()\n is called, it will be consulting the\n\nRuntimeDefinition\n, which uses Reflection to understand the structure of the\ncode. Once it knows the structure of the code, it can then know how the\ndependencies fit together and how to go about wiring your objects for you.\n\nZend\\Di\\Definition\\RuntimeDefinition\n will utilize the names of the parameters\nin the methods as the class parameter names. This is how both the \nusername\n and\n\npassword\n keys are mapped to the first and second parameters, respectively, of\nthe constructor consuming these named parameters.\n\n\nIf you were to want to pass in the username and password at call time, this is\nachieved by passing them as the second argument to \nget()\n:\n\n\n$di = new Zend\\Di\\Di();\n$movieLister = $di->get('MyMovieApp\\MovieLister', [\n    'username' => $config->username,\n    'password' => $config->password\n]);\nforeach ($movieLister as $movie) {\n    // iterate and display $movie\n}\n\n\n\n\nIt is important to note that when using call time parameters, these parameter\nnames will be applied to any class that accepts a parameter of such name.\n\n\nBy calling \n$di->get()\n, this instance of \nMovieLister\n will be automatically\nshared. This means subsequent calls to \nget()\n will return the same instance as\nprevious calls. If you wish to have completely new instances of \nMovieLister\n,\nyou can utilize \n$di->newInstance()\n.",
            "title": "Quick Start"
        },
        {
            "location": "/quick-start/#quick-start",
            "text": "This quick start is intended to get developers familiar with the concepts of the\nzend-di DiC.  Generally speaking, code is never as simple as it is inside this\nexample, so working knowledge of the other sections of the manual is suggested.  Assume, for a moment, the following application code. It already assumes that\ndependencies are injected, and so becomes a good candiate for a DiC.  namespace MyLibrary\n{\n    class DbAdapter\n    {\n        protected $username = null;\n        protected $password = null;\n\n        public function __construct($username, $password)\n        {\n            $this->username = $username;\n            $this->password = $password;\n        }\n    }\n}\n\nnamespace MyMovieApp\n{\n    class MovieFinder\n    {\n        protected $dbAdapter = null;\n\n        public function __construct(\\MyLibrary\\DbAdapter $dbAdapter)\n        {\n            $this->dbAdapter = $dbAdapter;\n        }\n    }\n\n    class MovieLister\n    {\n        protected $movieFinder = null;\n\n        public function __construct(MovieFinder $movieFinder)\n        {\n            $this->movieFinder = $movieFinder;\n        }\n    }\n}  With the above code, you find yourself writing the following to wire and utilize\nit:  // $config object is assumed\n\n$dbAdapter = new MyLibrary\\DbAdapter($config->username, $config->password);\n$movieFinder = new MyMovieApp\\MovieFinder($dbAdapter);\n$movieLister = new MyMovieApp\\MovieLister($movieFinder);\nforeach ($movieLister as $movie) {\n    // iterate and display $movie\n}  If you are doing this above wiring in each controller or view that wants to list\nmovies, not only can this become repetitive and boring to write, but also\nunmaintainable if you want to swap out one of these dependencies on a wholesale\nscale.  Since this example of code already practices good dependency injection using\nconstructor injection, it is a great candidate for using zend-di.  The following demonstrates how to wire the above into a zend-di container:  // Inside a bootstrap somewhere\n$di = new Zend\\Di\\Di();\n$di->instanceManager()->setParameters('MyLibrary\\DbAdapter', [\n    'username' => $config->username,\n    'password' => $config->password,\n]);\n\n// Elsewhere:\n$movieLister = $di->get('MyMovieApp\\MovieLister');\nforeach ($movieLister as $movie) {\n    // iterate and display $movie\n}  In the above example, we are obtaining a  default instance  of  Zend\\Di\\Di . By\n'default', we mean that  Zend\\\\Di\\\\Di  is constructed with a  DefinitionList \nseeded with a  RuntimeDefinition  (which uses PHP's Reflection API) and an empty\ninstance manager and no configuration:  public function __construct(\n    DefinitionList $definitions = null,\n    InstanceManager $instanceManager = null,\n    Configuration $config = null\n) {\n    $this->definitions = ($definitions) ?: new DefinitionList(new Definition\\RuntimeDefinition());\n    $this->instanceManager = ($instanceManager) ?: new InstanceManager();\n\n    if ($config) {\n        $this->configure($config);\n    }\n}  This means that when  $di->get()  is called, it will be consulting the RuntimeDefinition , which uses Reflection to understand the structure of the\ncode. Once it knows the structure of the code, it can then know how the\ndependencies fit together and how to go about wiring your objects for you. Zend\\Di\\Definition\\RuntimeDefinition  will utilize the names of the parameters\nin the methods as the class parameter names. This is how both the  username  and password  keys are mapped to the first and second parameters, respectively, of\nthe constructor consuming these named parameters.  If you were to want to pass in the username and password at call time, this is\nachieved by passing them as the second argument to  get() :  $di = new Zend\\Di\\Di();\n$movieLister = $di->get('MyMovieApp\\MovieLister', [\n    'username' => $config->username,\n    'password' => $config->password\n]);\nforeach ($movieLister as $movie) {\n    // iterate and display $movie\n}  It is important to note that when using call time parameters, these parameter\nnames will be applied to any class that accepts a parameter of such name.  By calling  $di->get() , this instance of  MovieLister  will be automatically\nshared. This means subsequent calls to  get()  will return the same instance as\nprevious calls. If you wish to have completely new instances of  MovieLister ,\nyou can utilize  $di->newInstance() .",
            "title": "Quick Start"
        },
        {
            "location": "/definitions/",
            "text": "Dependency Definitions\n\n\nDefinitions are what zend-di uses to understand the structure of the code it is\nattempting to wire. This means that if you've written non-ambiguous, clear and\nconcise code, zend-di has a very good chance of understanding how to wire things\nup without much added complexity.\n\n\nDefinitionList\n\n\nDefinitions are introduced to the \nZend\\Di\\Di\n object through a definition list\nimplemented as \nZend\\Di\\DefinitionList\n (which extends \nSplDoublyLinkedList\n).\nOrder is important. Definitions in the front of the list will be consulted on a\nclass before definitions at the end of the list.\n\n\n\n\nAutoloading\n\n\nRegardless of what kind of DefinitionList strategy you decide to use, it is\nimportant that your autoloaders are already setup and ready to use.\n\n\n\n\nRuntimeDefinition\n\n\nThe default \nDefinitionList\n instantiated by \nZend\\Di\\Di\n when no other\nDefinitionList is provided is \nZend\\Di\\Definition\\RuntimeDefinition\n. The\n\nRuntimeDefinition\n will respond to queries about classes by using PHP's\nReflection API. The \nRuntimeDefinition\n uses any available information inside\nmethods \u2014 including their signature, the names of parameters, the\ntype-hints of the parameters, and the default values \u2014 to determine if\nsomething is optional or required when making a call to that method. The more\nexplicit you can be in your method naming and method signatures, the more likely\n\nZend\\Di\\Definition\\RuntimeDefinition\n will accurately understand the structure\nof your code.\n\n\nThe constructor of \nRuntimeDefinition\n looks like the following:\n\n\npublic function __construct(\n    IntrospectionStrategy $introspectionStrategy = null,\n    array $explicitClasses = null\n) {\n    $this->introspectionStrategy = ($introspectionStrategy) ?: new IntrospectionStrategy();\n    if ($explicitClasses) {\n        $this->setExplicitClasses($explicitClasses);\n    }\n}\n\n\n\n\nThe \nIntrospectionStrategy\n object is an object that defines the rules by which\nthe \nRuntimeDefinition\n will introspect information about your classes. Here are\nthe things it knows how to do:\n\n\n\n\nWhether or not to use annotations (scanning and parsing annotations is\n  expensive, and thus disabled by default)\n\n\nWhich method names to include in the introspection; this is a list of\n  patterns. By default, it registers the pattern \n/^set\\[A-Z\\]{1}\\\\w\\*/\n.\n\n\nWhich interface names represent the interface injection pattern; this is a\n  list of patterns. By default, the pattern \n/\\\\w\\*Aware\\\\w\\*/\n is registered.\n\n\n\n\nThe constructor for the \nIntrospectionStrategy\n looks like this:\n\n\npublic function __construct(AnnotationManager $annotationManager = null)\n{\n    $this->annotationManager = ($annotationManager) ?: $this->createDefaultAnnotationManager();\n}\n\n\n\n\nThe \nAnnotationManager\n is not required. If you wish to create a special\n\nAnnotationManager\n with your own annotations, and also wish to extend the\n\nRuntimeDefinition\n to look for those annotations, this is the place to do it.\n\n\nThe \nRuntimeDefinition\n also can be used to look up either all classes\n(implicitly, which is default), or explicitly look up for particular pre-defined\nclasses. This is useful when your strategy for inspecting one set of classes\nmight differ from those of another strategy for another set of classes. This can\nbe achieved by using the \nsetExplicitClasses()\n method or by passing a list of\nclasses as the second constructor argument of the \nRuntimeDefinition\n.\n\n\nCompilerDefinition\n\n\nThe \nCompilerDefinition\n is similar in nature to the \nRuntimeDefinition\n with the exception\nthat it can be seeded with more information for the purposes of \"compiling\" a\ndefinition. Compiled definitions eliminate reflection calls and annotation\nscannning, which can be a performance bottleneck in your production\napplications.\n\n\nFor example, let's assume we want to create a script that will create\ndefinitions for some of our library code:\n\n\n// in \"package name\" format\n$components = [\n    'My_MovieApp',\n    'My_OtherClasses',\n];\n\nforeach ($components as $component) {\n    $diCompiler = new Zend\\Di\\Definition\\CompilerDefinition;\n    $diCompiler->addDirectory('/path/to/classes/' . str_replace('_', '/', $component));\n\n    $diCompiler->compile();\n    file_put_contents(\n        __DIR__ . '/../data/di/' . $component . '-definition.php',\n        '<?php return ' . var_export($diCompiler->toArrayDefinition()->toArray(), true) . ';'\n    );\n}\n\n\n\n\nThe above creates a file for each \"package\", containing the full definition for\nthe classes defined for each. To utilize this in an application, use the\nfollowing:\n\n\nprotected function setupDi(Application $app)\n{\n    $definitionList = new DefinitionList([\n        new Definition\\ArrayDefinition(include __DIR__ .  '/path/to/data/di/My_MovieApp-definition.php'),\n        new Definition\\ArrayDefinition(include __DIR__ .  '/path/to/data/di/My_OtherClasses-definition.php'),\n        $runtime = new Definition\\RuntimeDefinition(),\n    ]);\n    $di = new Di($definitionList, null, new Config($this->config->di));\n    $di->instanceManager()->addTypePreference('Zend\\Di\\LocatorInterface', $di);\n    $app->setLocator($di);\n}\n\n\n\n\nThe above code would more than likely go inside your application's bootstrap or\nwithin a \nModule\n class. This represents the simplest and most performant way\nof configuring your DiC for usage.\n\n\nClassDefinition\n\n\nThe idea behind using a \nClassDefinition\n is two-fold. First, you may want to\noverride some information inside of a \nRuntimeDefinition\n. Secondly, you might\nwant to simply define your complete class's definition with an xml, ini, or php\nfile describing the structure. This class definition can be fed in via\n\nConfiguration\n or by directly instantiating and registering the \nDefinition\n\nwith the \nDefinitionList\n.\n\n\n(@todo - example)",
            "title": "Definitions"
        },
        {
            "location": "/definitions/#dependency-definitions",
            "text": "Definitions are what zend-di uses to understand the structure of the code it is\nattempting to wire. This means that if you've written non-ambiguous, clear and\nconcise code, zend-di has a very good chance of understanding how to wire things\nup without much added complexity.",
            "title": "Dependency Definitions"
        },
        {
            "location": "/definitions/#definitionlist",
            "text": "Definitions are introduced to the  Zend\\Di\\Di  object through a definition list\nimplemented as  Zend\\Di\\DefinitionList  (which extends  SplDoublyLinkedList ).\nOrder is important. Definitions in the front of the list will be consulted on a\nclass before definitions at the end of the list.",
            "title": "DefinitionList"
        },
        {
            "location": "/definitions/#autoloading",
            "text": "Regardless of what kind of DefinitionList strategy you decide to use, it is\nimportant that your autoloaders are already setup and ready to use.",
            "title": "Autoloading"
        },
        {
            "location": "/definitions/#runtimedefinition",
            "text": "The default  DefinitionList  instantiated by  Zend\\Di\\Di  when no other\nDefinitionList is provided is  Zend\\Di\\Definition\\RuntimeDefinition . The RuntimeDefinition  will respond to queries about classes by using PHP's\nReflection API. The  RuntimeDefinition  uses any available information inside\nmethods \u2014 including their signature, the names of parameters, the\ntype-hints of the parameters, and the default values \u2014 to determine if\nsomething is optional or required when making a call to that method. The more\nexplicit you can be in your method naming and method signatures, the more likely Zend\\Di\\Definition\\RuntimeDefinition  will accurately understand the structure\nof your code.  The constructor of  RuntimeDefinition  looks like the following:  public function __construct(\n    IntrospectionStrategy $introspectionStrategy = null,\n    array $explicitClasses = null\n) {\n    $this->introspectionStrategy = ($introspectionStrategy) ?: new IntrospectionStrategy();\n    if ($explicitClasses) {\n        $this->setExplicitClasses($explicitClasses);\n    }\n}  The  IntrospectionStrategy  object is an object that defines the rules by which\nthe  RuntimeDefinition  will introspect information about your classes. Here are\nthe things it knows how to do:   Whether or not to use annotations (scanning and parsing annotations is\n  expensive, and thus disabled by default)  Which method names to include in the introspection; this is a list of\n  patterns. By default, it registers the pattern  /^set\\[A-Z\\]{1}\\\\w\\*/ .  Which interface names represent the interface injection pattern; this is a\n  list of patterns. By default, the pattern  /\\\\w\\*Aware\\\\w\\*/  is registered.   The constructor for the  IntrospectionStrategy  looks like this:  public function __construct(AnnotationManager $annotationManager = null)\n{\n    $this->annotationManager = ($annotationManager) ?: $this->createDefaultAnnotationManager();\n}  The  AnnotationManager  is not required. If you wish to create a special AnnotationManager  with your own annotations, and also wish to extend the RuntimeDefinition  to look for those annotations, this is the place to do it.  The  RuntimeDefinition  also can be used to look up either all classes\n(implicitly, which is default), or explicitly look up for particular pre-defined\nclasses. This is useful when your strategy for inspecting one set of classes\nmight differ from those of another strategy for another set of classes. This can\nbe achieved by using the  setExplicitClasses()  method or by passing a list of\nclasses as the second constructor argument of the  RuntimeDefinition .",
            "title": "RuntimeDefinition"
        },
        {
            "location": "/definitions/#compilerdefinition",
            "text": "The  CompilerDefinition  is similar in nature to the  RuntimeDefinition  with the exception\nthat it can be seeded with more information for the purposes of \"compiling\" a\ndefinition. Compiled definitions eliminate reflection calls and annotation\nscannning, which can be a performance bottleneck in your production\napplications.  For example, let's assume we want to create a script that will create\ndefinitions for some of our library code:  // in \"package name\" format\n$components = [\n    'My_MovieApp',\n    'My_OtherClasses',\n];\n\nforeach ($components as $component) {\n    $diCompiler = new Zend\\Di\\Definition\\CompilerDefinition;\n    $diCompiler->addDirectory('/path/to/classes/' . str_replace('_', '/', $component));\n\n    $diCompiler->compile();\n    file_put_contents(\n        __DIR__ . '/../data/di/' . $component . '-definition.php',\n        '<?php return ' . var_export($diCompiler->toArrayDefinition()->toArray(), true) . ';'\n    );\n}  The above creates a file for each \"package\", containing the full definition for\nthe classes defined for each. To utilize this in an application, use the\nfollowing:  protected function setupDi(Application $app)\n{\n    $definitionList = new DefinitionList([\n        new Definition\\ArrayDefinition(include __DIR__ .  '/path/to/data/di/My_MovieApp-definition.php'),\n        new Definition\\ArrayDefinition(include __DIR__ .  '/path/to/data/di/My_OtherClasses-definition.php'),\n        $runtime = new Definition\\RuntimeDefinition(),\n    ]);\n    $di = new Di($definitionList, null, new Config($this->config->di));\n    $di->instanceManager()->addTypePreference('Zend\\Di\\LocatorInterface', $di);\n    $app->setLocator($di);\n}  The above code would more than likely go inside your application's bootstrap or\nwithin a  Module  class. This represents the simplest and most performant way\nof configuring your DiC for usage.",
            "title": "CompilerDefinition"
        },
        {
            "location": "/definitions/#classdefinition",
            "text": "The idea behind using a  ClassDefinition  is two-fold. First, you may want to\noverride some information inside of a  RuntimeDefinition . Secondly, you might\nwant to simply define your complete class's definition with an xml, ini, or php\nfile describing the structure. This class definition can be fed in via Configuration  or by directly instantiating and registering the  Definition \nwith the  DefinitionList .  (@todo - example)",
            "title": "ClassDefinition"
        },
        {
            "location": "/instance-manager/",
            "text": "Instance Manager\n\n\nThe \nInstanceManager\n is responsible for any runtime information associated with\nthe zend-di DiC.  This means that the information that goes into the instance\nmanager is specific to both how the particular consuming application's needs,\nand even more specifically to the environment in which the application is\nrunning.\n\n\nParameters\n\n\nParameters are simply entry points for either dependencies or instance\nconfiguration values. A class consists of a set of parameters, each uniquely\nnamed. When writing your classes, you should attempt to not use the same\nparameter name twice in the same class when you expect that that parameters is\nused for either instance configuration or an object dependency. This leads to an\nambiguous parameter, and is a situation best avoided.\n\n\nOur movie finder example can be further used to explain these concepts:\n\n\nnamespace MyLibrary\n{\n    class DbAdapter\n    {\n        protected $username = null;\n        protected $password = null;\n\n        public function __construct($username, $password)\n        {\n            $this->username = $username;\n            $this->password = $password;\n        }\n    }\n}\n\nnamespace MyMovieApp\n{\n    class MovieFinder\n    {\n        protected $dbAdapter = null;\n\n        public function __construct(\\MyLibrary\\DbAdapter $dbAdapter)\n        {\n            $this->dbAdapter = $dbAdapter;\n        }\n    }\n\n    class MovieLister\n    {\n        protected $movieFinder = null;\n\n        public function __construct(MovieFinder $movieFinder)\n        {\n            $this->movieFinder = $movieFinder;\n        }\n    }\n}\n\n\n\n\nIn the above example, the class \nDbAdapter\n has 2 parameters: \nusername\n and\n\npassword\n; \nMovieFinder\n has one parameter: \ndbAdapter\n; and \nMovieLister\n has\none parameter: \nmovieFinder\n. Any of these can be utilized for injection of\neither dependencies or scalar values during instance configuration or during\ncall time.\n\n\nWhen looking at the above code, since the \ndbAdapter\n parameter and the\n\nmovieFinder\n parameter are both type-hinted with concrete types, the DiC can\nassume that it can fulfill these object tendencies by itself. On the other hand,\nusername and password do not have type-hints and are, more than likely, scalar\nin nature. Since the DiC cannot reasonably know this information, it must be\nprovided to the instance manager in the form of parameters. Not doing so will\nforce \n$di->get('MyMovieApp\\\\MovieLister')\n to throw an exception.\n\n\nThe following ways of using parameters are available:\n\n\n// setting instance configuration into the instance manager\n$di->instanceManager()->setParameters('MyLibrary\\DbAdapter', [\n    'username' => 'myusername',\n    'password' => 'mypassword',\n]);\n\n// forcing a particular dependency to be used by the instance manager\n$di->instanceManager()->setParameters('MyMovieApp\\MovieFinder', [\n    'dbAdapter' => new MyLibrary\\DbAdapter('myusername', 'mypassword')\n]);\n\n// passing instance parameters at call time\n$movieLister = $di->get('MyMovieApp\\MovieLister', [\n    'username' => $config->username,\n    'password' => $config->password,\n]);\n\n// passing a specific instance at call time\n$movieLister = $di->get('MyMovieApp\\MovieLister', [\n    'dbAdapter' => new MyLibrary\\DbAdapter('myusername', 'mypassword')\n]);\n\n\n\n\nPreferences\n\n\nIn many cases, you might be using interfaces as type hints as opposed to\nconcrete types. Lets assume the movie example was modified in the following way:\n\n\nnamespace MyMovieApp\n{\n    interface MovieFinderInterface\n    {\n        // methods required for this type\n    }\n\n    class GenericMovieFinder implements MovieFinderInterface\n    {\n        protected $dbAdapter = null;\n\n        public function __construct(\\MyLibrary\\DbAdapter $dbAdapter)\n        {\n            $this->dbAdapter = $dbAdapter;\n        }\n    }\n\n    class MovieLister\n    {\n        protected $movieFinder = null;\n\n        public function __construct(MovieFinderInterface $movieFinder)\n        {\n            $this->movieFinder = $movieFinder;\n        }\n    }\n}\n\n\n\n\nWhat you'll notice above is that the \nMovieLister\n type now expects that the\ndependency injected implements the \nMovieFinderInterface\n. This allows multiple\nimplementations of this base interface to be used as a dependency, if that is\nwhat the consumer decides they want to do. As you can imagine, zend-di, by\nitself would not be able to determine what kind of concrete object to use\nfulfill this dependency, so this type of 'preference' needs to be made known to\nthe instance manager.\n\n\nTo give this information to the instance manager, see the following code\nexample:\n\n\n$di->instanceManager()->addTypePreference(\n    'MyMovieApp\\MovieFinderInterface',\n    'MyMovieApp\\GenericMovieFinder'\n);\n\n// assuming all instance config for username, password is setup\n$di->get('MyMovieApp\\MovieLister');\n\n\n\n\nAliases\n\n\nIn some situations, you'll find that you need to alias an instance. There are\ntwo main reasons to do this. First, it creates a simpler, alternative name to\nuse when using the DiC, as opposed to using the full class name. Second, you\nmight find that you need to have the same object type in two separate contexts.\nThis means that when you alias a particular class, you can then attach a\nspecific instance configuration to that alias, as opposed to attaching that\nconfiguration to the class name.\n\n\nTo demonstrate both of these points, we'll look at a use case where we'll have\ntwo separate database adapters. One will be for read-only operations, the other\nwill be for read-write operations.\n\n\n\n\nAlias parameters\n\n\nAliases can also have parameters registered at alias time.\n\n\n\n\n// assume the MovieLister example of code from the quick start.\n\n$im = $di->instanceManager();\n\n// add alias for short naming\n$im->addAlias('movielister', 'MyMovieApp\\MovieLister');\n\n// add aliases for specific instances\n$im->addAlias('dbadapter-readonly', 'MyLibrary\\DbAdapter', [\n    'username' => $config->db->readAdapter->username,\n    'password' => $config->db->readAdapter->password,\n]);\n$im->addAlias('dbadapter-readwrite', 'MyLibrary\\DbAdapter', [\n    'username' => $config->db->readWriteAdapter->username,\n    'password' => $config->db->readWriteAdapter->password,\n]);\n\n// set a default type to use, pointing to an alias\n$im->addTypePreference('MyLibrary\\DbAdapter', 'dbadapter-readonly');\n\n$movieListerRead = $di->get('MyMovieApp\\MovieLister');\n$movieListerReadWrite = $di->get('MyMovieApp\\MovieLister', [\n    'dbAdapter' => 'dbadapter-readwrite',\n]);",
            "title": "Instance Manager"
        },
        {
            "location": "/instance-manager/#instance-manager",
            "text": "The  InstanceManager  is responsible for any runtime information associated with\nthe zend-di DiC.  This means that the information that goes into the instance\nmanager is specific to both how the particular consuming application's needs,\nand even more specifically to the environment in which the application is\nrunning.",
            "title": "Instance Manager"
        },
        {
            "location": "/instance-manager/#parameters",
            "text": "Parameters are simply entry points for either dependencies or instance\nconfiguration values. A class consists of a set of parameters, each uniquely\nnamed. When writing your classes, you should attempt to not use the same\nparameter name twice in the same class when you expect that that parameters is\nused for either instance configuration or an object dependency. This leads to an\nambiguous parameter, and is a situation best avoided.  Our movie finder example can be further used to explain these concepts:  namespace MyLibrary\n{\n    class DbAdapter\n    {\n        protected $username = null;\n        protected $password = null;\n\n        public function __construct($username, $password)\n        {\n            $this->username = $username;\n            $this->password = $password;\n        }\n    }\n}\n\nnamespace MyMovieApp\n{\n    class MovieFinder\n    {\n        protected $dbAdapter = null;\n\n        public function __construct(\\MyLibrary\\DbAdapter $dbAdapter)\n        {\n            $this->dbAdapter = $dbAdapter;\n        }\n    }\n\n    class MovieLister\n    {\n        protected $movieFinder = null;\n\n        public function __construct(MovieFinder $movieFinder)\n        {\n            $this->movieFinder = $movieFinder;\n        }\n    }\n}  In the above example, the class  DbAdapter  has 2 parameters:  username  and password ;  MovieFinder  has one parameter:  dbAdapter ; and  MovieLister  has\none parameter:  movieFinder . Any of these can be utilized for injection of\neither dependencies or scalar values during instance configuration or during\ncall time.  When looking at the above code, since the  dbAdapter  parameter and the movieFinder  parameter are both type-hinted with concrete types, the DiC can\nassume that it can fulfill these object tendencies by itself. On the other hand,\nusername and password do not have type-hints and are, more than likely, scalar\nin nature. Since the DiC cannot reasonably know this information, it must be\nprovided to the instance manager in the form of parameters. Not doing so will\nforce  $di->get('MyMovieApp\\\\MovieLister')  to throw an exception.  The following ways of using parameters are available:  // setting instance configuration into the instance manager\n$di->instanceManager()->setParameters('MyLibrary\\DbAdapter', [\n    'username' => 'myusername',\n    'password' => 'mypassword',\n]);\n\n// forcing a particular dependency to be used by the instance manager\n$di->instanceManager()->setParameters('MyMovieApp\\MovieFinder', [\n    'dbAdapter' => new MyLibrary\\DbAdapter('myusername', 'mypassword')\n]);\n\n// passing instance parameters at call time\n$movieLister = $di->get('MyMovieApp\\MovieLister', [\n    'username' => $config->username,\n    'password' => $config->password,\n]);\n\n// passing a specific instance at call time\n$movieLister = $di->get('MyMovieApp\\MovieLister', [\n    'dbAdapter' => new MyLibrary\\DbAdapter('myusername', 'mypassword')\n]);",
            "title": "Parameters"
        },
        {
            "location": "/instance-manager/#preferences",
            "text": "In many cases, you might be using interfaces as type hints as opposed to\nconcrete types. Lets assume the movie example was modified in the following way:  namespace MyMovieApp\n{\n    interface MovieFinderInterface\n    {\n        // methods required for this type\n    }\n\n    class GenericMovieFinder implements MovieFinderInterface\n    {\n        protected $dbAdapter = null;\n\n        public function __construct(\\MyLibrary\\DbAdapter $dbAdapter)\n        {\n            $this->dbAdapter = $dbAdapter;\n        }\n    }\n\n    class MovieLister\n    {\n        protected $movieFinder = null;\n\n        public function __construct(MovieFinderInterface $movieFinder)\n        {\n            $this->movieFinder = $movieFinder;\n        }\n    }\n}  What you'll notice above is that the  MovieLister  type now expects that the\ndependency injected implements the  MovieFinderInterface . This allows multiple\nimplementations of this base interface to be used as a dependency, if that is\nwhat the consumer decides they want to do. As you can imagine, zend-di, by\nitself would not be able to determine what kind of concrete object to use\nfulfill this dependency, so this type of 'preference' needs to be made known to\nthe instance manager.  To give this information to the instance manager, see the following code\nexample:  $di->instanceManager()->addTypePreference(\n    'MyMovieApp\\MovieFinderInterface',\n    'MyMovieApp\\GenericMovieFinder'\n);\n\n// assuming all instance config for username, password is setup\n$di->get('MyMovieApp\\MovieLister');",
            "title": "Preferences"
        },
        {
            "location": "/instance-manager/#aliases",
            "text": "In some situations, you'll find that you need to alias an instance. There are\ntwo main reasons to do this. First, it creates a simpler, alternative name to\nuse when using the DiC, as opposed to using the full class name. Second, you\nmight find that you need to have the same object type in two separate contexts.\nThis means that when you alias a particular class, you can then attach a\nspecific instance configuration to that alias, as opposed to attaching that\nconfiguration to the class name.  To demonstrate both of these points, we'll look at a use case where we'll have\ntwo separate database adapters. One will be for read-only operations, the other\nwill be for read-write operations.",
            "title": "Aliases"
        },
        {
            "location": "/instance-manager/#alias-parameters",
            "text": "Aliases can also have parameters registered at alias time.   // assume the MovieLister example of code from the quick start.\n\n$im = $di->instanceManager();\n\n// add alias for short naming\n$im->addAlias('movielister', 'MyMovieApp\\MovieLister');\n\n// add aliases for specific instances\n$im->addAlias('dbadapter-readonly', 'MyLibrary\\DbAdapter', [\n    'username' => $config->db->readAdapter->username,\n    'password' => $config->db->readAdapter->password,\n]);\n$im->addAlias('dbadapter-readwrite', 'MyLibrary\\DbAdapter', [\n    'username' => $config->db->readWriteAdapter->username,\n    'password' => $config->db->readWriteAdapter->password,\n]);\n\n// set a default type to use, pointing to an alias\n$im->addTypePreference('MyLibrary\\DbAdapter', 'dbadapter-readonly');\n\n$movieListerRead = $di->get('MyMovieApp\\MovieLister');\n$movieListerReadWrite = $di->get('MyMovieApp\\MovieLister', [\n    'dbAdapter' => 'dbadapter-readwrite',\n]);",
            "title": "Alias parameters"
        },
        {
            "location": "/config/",
            "text": "Configuration\n\n\nMost of the configuration for both the setup of \nDefinition\ns as well as the\nsetup of the \nInstanceManager\n can be attained by a configuration file. This\nfile will produce an array (typically) and have an iterable structure.\n\n\nThe top two keys are 'definition' and 'instance', each specifying values for\nthe definition setup and instance manager setup, respectively.\n\n\nThe definition section expects the following information expressed as a PHP\narray:\n\n\n$config = [\n    'definition' => [\n        'compiler' => [/* @todo compiler information */],\n        'runtime'  => [/* @todo runtime information */],\n        'class' => [\n            'instantiator' => '', // the name of the instantiator, by default this is __construct\n            'supertypes'   => [], // an array of supertypes the class implements\n            'methods'      => [\n                'setSomeParameter' => [ // a method name\n                    'parameterName' => [\n                        'name',        // string parameter name\n                        'type',        // type or null\n                        'is-required', // bool\n                    ),\n                ),\n            ),\n        ),\n    ),\n);",
            "title": "Configuration"
        },
        {
            "location": "/config/#configuration",
            "text": "Most of the configuration for both the setup of  Definition s as well as the\nsetup of the  InstanceManager  can be attained by a configuration file. This\nfile will produce an array (typically) and have an iterable structure.  The top two keys are 'definition' and 'instance', each specifying values for\nthe definition setup and instance manager setup, respectively.  The definition section expects the following information expressed as a PHP\narray:  $config = [\n    'definition' => [\n        'compiler' => [/* @todo compiler information */],\n        'runtime'  => [/* @todo runtime information */],\n        'class' => [\n            'instantiator' => '', // the name of the instantiator, by default this is __construct\n            'supertypes'   => [], // an array of supertypes the class implements\n            'methods'      => [\n                'setSomeParameter' => [ // a method name\n                    'parameterName' => [\n                        'name',        // string parameter name\n                        'type',        // type or null\n                        'is-required', // bool\n                    ),\n                ),\n            ),\n        ),\n    ),\n);",
            "title": "Configuration"
        },
        {
            "location": "/debugging-and-complex-use-cases/",
            "text": "Debugging & Complex Use Cases\n\n\nDebugging a DiC\n\n\nIt is possible to dump the information contained within both the \nDefinition\n\nand \nInstanceManager\n for a \nZend\\Di\\Di\n instance.\n\n\nThe easiest way is to do the following:\n\n\nZend\\Di\\Display\\Console::export($di);\n\n\n\n\nIf you are using a \nRuntimeDefinition\n where upon you expect a particular\ndefinition to be resolve at the first-call, you can see that information to the\nconsole display to force it to read that class:\n\n\nZend\\Di\\Display\\Console::export($di, ['A\\ClassIWantTo\\GetTheDefinitionFor']);\n\n\n\n\nComplex Use Cases\n\n\nInterface Injection\n\n\nnamespace Foo\\Bar\n{\n    class Baz implements BamAwareInterface\n    {\n        public $bam;\n\n        public function setBam(Bam $bam)\n        {\n            $this->bam = $bam;\n        }\n    }\n\n    class Bam\n    {\n    }\n\n    interface BamAwareInterface\n    {\n        public function setBam(Bam $bam);\n    }\n}\n\nnamespace {\n    include 'zf2bootstrap.php';\n    $di = new Zend\\Di\\Di;\n    $baz = $di->get('Foo\\Bar\\Baz');\n}\n\n\n\n\nSetter Injection with Class Definition\n\n\nnamespace Foo\\Bar\n{\n    class Baz\n    {\n        public $bam;\n\n        public function setBam(Bam $bam)\n        {\n            $this->bam = $bam;\n        }\n    }\n\n    class Bam {\n    }\n}\n\nnamespace {\n    $di = new Zend\\Di\\Di;\n    $di->configure(new Zend\\Di\\Config([\n        'definition' => [\n            'class' => [\n                'Foo\\Bar\\Baz' => [\n                    'setBam' => ['required' => true],\n                ],\n            ],\n        ],\n    ]));\n    $baz = $di->get('Foo\\Bar\\Baz');\n}\n\n\n\n\nMultiple Injections To A Single Injection Point\n\n\nnamespace Application\n{\n    class Page\n    {\n        public $blocks;\n\n        public function addBlock(Block $block)\n        {\n            $this->blocks[] = $block;\n        }\n    }\n\n    interface Block\n    {\n    }\n}\n\nnamespace MyModule {\n    class BlockOne implements \\Application\\Block {}\n    class BlockTwo implements \\Application\\Block {}\n}\n\nnamespace {\n    include 'zf2bootstrap.php';\n    $di = new Zend\\Di\\Di;\n    $di->configure(new Zend\\Di\\Config([\n        'definition' => [\n            'class' => [\n                'Application\\Page' => [\n                    'addBlock' => [\n                        'block' => [\n                            'type' => 'Application\\Block',\n                            'required' => true\n                        ],\n                    ],\n                ],\n            ],\n        ],\n        'instance' => [\n            'Application\\Page' => [\n                'injections' => [\n                    'MyModule\\BlockOne',\n                    'MyModule\\BlockTwo',\n                ],\n            ],\n        ],\n    ]));\n    $page = $di->get('Application\\Page');\n}",
            "title": "Debugging and Complex Use Cases"
        },
        {
            "location": "/debugging-and-complex-use-cases/#debugging-complex-use-cases",
            "text": "",
            "title": "Debugging &amp; Complex Use Cases"
        },
        {
            "location": "/debugging-and-complex-use-cases/#debugging-a-dic",
            "text": "It is possible to dump the information contained within both the  Definition \nand  InstanceManager  for a  Zend\\Di\\Di  instance.  The easiest way is to do the following:  Zend\\Di\\Display\\Console::export($di);  If you are using a  RuntimeDefinition  where upon you expect a particular\ndefinition to be resolve at the first-call, you can see that information to the\nconsole display to force it to read that class:  Zend\\Di\\Display\\Console::export($di, ['A\\ClassIWantTo\\GetTheDefinitionFor']);",
            "title": "Debugging a DiC"
        },
        {
            "location": "/debugging-and-complex-use-cases/#complex-use-cases",
            "text": "",
            "title": "Complex Use Cases"
        },
        {
            "location": "/debugging-and-complex-use-cases/#interface-injection",
            "text": "namespace Foo\\Bar\n{\n    class Baz implements BamAwareInterface\n    {\n        public $bam;\n\n        public function setBam(Bam $bam)\n        {\n            $this->bam = $bam;\n        }\n    }\n\n    class Bam\n    {\n    }\n\n    interface BamAwareInterface\n    {\n        public function setBam(Bam $bam);\n    }\n}\n\nnamespace {\n    include 'zf2bootstrap.php';\n    $di = new Zend\\Di\\Di;\n    $baz = $di->get('Foo\\Bar\\Baz');\n}",
            "title": "Interface Injection"
        },
        {
            "location": "/debugging-and-complex-use-cases/#setter-injection-with-class-definition",
            "text": "namespace Foo\\Bar\n{\n    class Baz\n    {\n        public $bam;\n\n        public function setBam(Bam $bam)\n        {\n            $this->bam = $bam;\n        }\n    }\n\n    class Bam {\n    }\n}\n\nnamespace {\n    $di = new Zend\\Di\\Di;\n    $di->configure(new Zend\\Di\\Config([\n        'definition' => [\n            'class' => [\n                'Foo\\Bar\\Baz' => [\n                    'setBam' => ['required' => true],\n                ],\n            ],\n        ],\n    ]));\n    $baz = $di->get('Foo\\Bar\\Baz');\n}",
            "title": "Setter Injection with Class Definition"
        },
        {
            "location": "/debugging-and-complex-use-cases/#multiple-injections-to-a-single-injection-point",
            "text": "namespace Application\n{\n    class Page\n    {\n        public $blocks;\n\n        public function addBlock(Block $block)\n        {\n            $this->blocks[] = $block;\n        }\n    }\n\n    interface Block\n    {\n    }\n}\n\nnamespace MyModule {\n    class BlockOne implements \\Application\\Block {}\n    class BlockTwo implements \\Application\\Block {}\n}\n\nnamespace {\n    include 'zf2bootstrap.php';\n    $di = new Zend\\Di\\Di;\n    $di->configure(new Zend\\Di\\Config([\n        'definition' => [\n            'class' => [\n                'Application\\Page' => [\n                    'addBlock' => [\n                        'block' => [\n                            'type' => 'Application\\Block',\n                            'required' => true\n                        ],\n                    ],\n                ],\n            ],\n        ],\n        'instance' => [\n            'Application\\Page' => [\n                'injections' => [\n                    'MyModule\\BlockOne',\n                    'MyModule\\BlockTwo',\n                ],\n            ],\n        ],\n    ]));\n    $page = $di->get('Application\\Page');\n}",
            "title": "Multiple Injections To A Single Injection Point"
        }
    ]
}