{
    "docs": [
        {
            "location": "/",
            "text": "zend-di\n\n\n\n\n\n\nzend-di provides autowiring to implement Inversion of Control (IoC) containers.\nIoC containers are widely used to create object instances that have all\ndependencies resolved and injected. Dependency Injection containers are one form\nof IoC \u2013 but not the only form.\n\n\nzend-di is designed to be simple, fast and reusable. It provides the following features:\n\n\n\n\nConstructor injection\n\n\nAutowiring:\n\n\nRecursively through all dependencies\n\n\nWith configured type preferences\n\n\nwith configured injections\n\n\nWith injections passed in the create() call\n\n\nCode generators to create factories usable by other IoC containers like Zend\\ServiceManager\n\n\n\n\nIt does \nnot\n provide:\n\n\n\n\nSetter, interface, property or any other injection method than constructor injection\n\n\nSupport for factories\n\n\nDeclaring shared/unshared instances\n\n\nthe injector always creates new instances\n\n\nthe default container always shares instances\n\n\nSupport for variadic arguments in __construct\n\n\n\n\nIf you need these features combine it with another IoC container such as\n\nzend-servicemanager\n.\n\n\n\n\nFile issues at https://github.com/zendframework/zend-di/issues\n\n\nDocumentation is at https://docs.zendframework.com/zend-di/",
            "title": "zend-di"
        },
        {
            "location": "/#zend-di",
            "text": "zend-di provides autowiring to implement Inversion of Control (IoC) containers.\nIoC containers are widely used to create object instances that have all\ndependencies resolved and injected. Dependency Injection containers are one form\nof IoC \u2013 but not the only form.  zend-di is designed to be simple, fast and reusable. It provides the following features:   Constructor injection  Autowiring:  Recursively through all dependencies  With configured type preferences  with configured injections  With injections passed in the create() call  Code generators to create factories usable by other IoC containers like Zend\\ServiceManager   It does  not  provide:   Setter, interface, property or any other injection method than constructor injection  Support for factories  Declaring shared/unshared instances  the injector always creates new instances  the default container always shares instances  Support for variadic arguments in __construct   If you need these features combine it with another IoC container such as zend-servicemanager .   File issues at https://github.com/zendframework/zend-di/issues  Documentation is at https://docs.zendframework.com/zend-di/",
            "title": "zend-di"
        },
        {
            "location": "/intro/",
            "text": "Introduction\n\n\nDependency Injection\n\n\nDependency Injection\n (here-in called DI) refers to the act of providing\ndependencies for an object during instantiation or via a method call. A basic\nexample looks like this:\n\n\n$b = new MovieLister(new MovieFinder());\n\n\n\nAbove, \nMovieFinder\n is a dependency of \nMovieLister\n, and \nMovieFinder\n was\ninjected into \nMovieLister\n.\n\n\nThere are several forms of dependency injection:\n\n\n\n\nConstructor injection\n\n\nSetter injection\n\n\nProperty (or field) injection\n\n\n\n\nWhile previous versions of zend-di attempted to handle all three types, starting\nin version 3, the component focuses only on the first, constructor injection.\nThis decision was made for several reasons:\n\n\n\n\nIt simplified the implementation dramatically.\n\n\nThe simplified implementation had performance benefits.\n\n\nIt enforces the order of object initialization, which both helps to prevent\n  circular dependencies, and ensures the completeness of the instantiated object.\n\n\n\n\n\n\nFurther reading\n\n\nIf you are not familiar with the concept of DI, here are several great reads:\n\n\n\n\nMatthew Weier O'Phinney's Analogy\n\n\nRalph Schindler's Learning DI\n\n\nFabien Potencier's Series\n on DI\n\n\n\n\nzend-servicemanager\n\n\nSince zend-di purely provides automatic DI (aka auto wiring), it does not\nprovide code-driven \nInversion of Control\n (IoC).\n\n\nHowever, Zend Framework does ship with another IoC component as well: \nzend-servicemanager\n.\nUnlike zend-di, zend-servicemanager is code-driven, meaning that you tell it\nwhat class to instantiate, or provide a factory for the given class. This allows\nyou more fine-grained control on how your objects will be instantiated.\n\n\nIn fact zend-di is designed to play nicely with other IoC containers that\nimplement PSR-11, especially with zend-servicemanager. You can even use\nfactories generated by zend-di for zend-servicemanager.\n\n\n\n\nDependency Injection Containers\n\n\nWhen your code is written in such a way that all your dependencies are injected\ninto consuming objects, you might find that the simple act of wiring an object\nhas gotten more complex. When this becomes the case, and you find that this\nwiring is creating more boilerplate code, this makes for an excellent\nopportunity to utilize a Dependency Injection Container. These containers are also\noften referred to as IoC Containers.\n\n\nIn its simplest form, a Dependency Injection Container (here-in called a DiC\nfor brevity) is an object that is capable of creating objects on request and\nmanaging the \"wiring\", or the injection of required dependencies, for those\nrequested objects. Since the patterns that developers employ in writing DI\ncapable code vary, DiC's are generally either in the form of smallish objects\nthat suit a very specific pattern, or larger DiC frameworks.\n\n\nThe PHP FIG defined a standard interface for such DiCs via \nPSR-11\n(ContainerInterface)\n.\n\n\nzend-di is a DiC framework which provides an injector performing the wiring, and\na simple imlementation of a DiC. The injector is able to consume any PSR-11\ncontainer, such as \nzend-servicemanager\n,\nto obtain the instances of the dependencies.\n\n\nWhile for the simplest use cases no configuration is needed, zend-di allows\ndevelopers to configure how to resolve dependencies for more complex use cases.\n\n\nLegacy documentation\n\n\nThe primary documentation covers version 3.0 and above. We also ship\ndocumentation covering version 2 features, starting with a chapter covering\n\nzend-di Definition classes\n.",
            "title": "Intro"
        },
        {
            "location": "/intro/#introduction",
            "text": "",
            "title": "Introduction"
        },
        {
            "location": "/intro/#dependency-injection",
            "text": "Dependency Injection  (here-in called DI) refers to the act of providing\ndependencies for an object during instantiation or via a method call. A basic\nexample looks like this:  $b = new MovieLister(new MovieFinder());  Above,  MovieFinder  is a dependency of  MovieLister , and  MovieFinder  was\ninjected into  MovieLister .  There are several forms of dependency injection:   Constructor injection  Setter injection  Property (or field) injection   While previous versions of zend-di attempted to handle all three types, starting\nin version 3, the component focuses only on the first, constructor injection.\nThis decision was made for several reasons:   It simplified the implementation dramatically.  The simplified implementation had performance benefits.  It enforces the order of object initialization, which both helps to prevent\n  circular dependencies, and ensures the completeness of the instantiated object.",
            "title": "Dependency Injection"
        },
        {
            "location": "/intro/#further-reading",
            "text": "If you are not familiar with the concept of DI, here are several great reads:   Matthew Weier O'Phinney's Analogy  Ralph Schindler's Learning DI  Fabien Potencier's Series  on DI",
            "title": "Further reading"
        },
        {
            "location": "/intro/#zend-servicemanager",
            "text": "Since zend-di purely provides automatic DI (aka auto wiring), it does not\nprovide code-driven  Inversion of Control  (IoC).  However, Zend Framework does ship with another IoC component as well:  zend-servicemanager .\nUnlike zend-di, zend-servicemanager is code-driven, meaning that you tell it\nwhat class to instantiate, or provide a factory for the given class. This allows\nyou more fine-grained control on how your objects will be instantiated.  In fact zend-di is designed to play nicely with other IoC containers that\nimplement PSR-11, especially with zend-servicemanager. You can even use\nfactories generated by zend-di for zend-servicemanager.",
            "title": "zend-servicemanager"
        },
        {
            "location": "/intro/#dependency-injection-containers",
            "text": "When your code is written in such a way that all your dependencies are injected\ninto consuming objects, you might find that the simple act of wiring an object\nhas gotten more complex. When this becomes the case, and you find that this\nwiring is creating more boilerplate code, this makes for an excellent\nopportunity to utilize a Dependency Injection Container. These containers are also\noften referred to as IoC Containers.  In its simplest form, a Dependency Injection Container (here-in called a DiC\nfor brevity) is an object that is capable of creating objects on request and\nmanaging the \"wiring\", or the injection of required dependencies, for those\nrequested objects. Since the patterns that developers employ in writing DI\ncapable code vary, DiC's are generally either in the form of smallish objects\nthat suit a very specific pattern, or larger DiC frameworks.  The PHP FIG defined a standard interface for such DiCs via  PSR-11\n(ContainerInterface) .  zend-di is a DiC framework which provides an injector performing the wiring, and\na simple imlementation of a DiC. The injector is able to consume any PSR-11\ncontainer, such as  zend-servicemanager ,\nto obtain the instances of the dependencies.  While for the simplest use cases no configuration is needed, zend-di allows\ndevelopers to configure how to resolve dependencies for more complex use cases.",
            "title": "Dependency Injection Containers"
        },
        {
            "location": "/intro/#legacy-documentation",
            "text": "The primary documentation covers version 3.0 and above. We also ship\ndocumentation covering version 2 features, starting with a chapter covering zend-di Definition classes .",
            "title": "Legacy documentation"
        },
        {
            "location": "/quick-start/",
            "text": "Quick Start\n\n\nThe DI component provides an auto wiring strategy which implements\n\nconstructor injection\n.\n\n\nIt utilizes \nPSR-11\n containers to obtain required services, so it\ncan be paired with any IoC container that implements this interface, such as\n\nzend-servicemanager\n.\n\n\n1. Installation\n\n\nIf you haven't already, \ninstall Composer\n.\nOnce you have, you can install zend-di:\n\n\n$ composer install zendframework/zend-di\n\n\n\n2. Configuring the injector\n\n\nYou can now create and configure an injector instance. The injector accepts an\ninstance of \nZend\\Di\\ConfigInterface\n. This can be provided by passing\n\nZend\\Di\\Config\n, which accepts a PHP array to its constructor:\n\n\nuse Zend\\Di\\Injector;\nuse Zend\\Di\\Config;\n\n$injector = new Injector(new Config([\n    'preferences' => [\n        MyInterface::class => MyImplementation::class,\n    ],\n]));\n\n\n\nThis config implementation accepts a veriety of options. Refer to the\n\nConfiguration\n chapter for full details.\n\n\n3. Creating instances\n\n\nFinally, you can create new instances of a specific class or alias by using the\n\ncreate()\n method:\n\n\n$instance = $injector->create(MyClass::class);\n\n\n\nThe only precondition is that the class you provide to \ncreate()\n must exist (or\nbe autoloadable).  If this is not the case, the injector will fail with an\nexception.\n\n\nThe \ncreate()\n method will \nalways\n create a new instance of the given class. If\nyou need a shared instance, you can associate an IoC container implementing\nPSR-11 with the injector:\n\n\n$injector = new Injector($config, $container);\n\n$sharedInstance = $injector->getContainer()->get(MyClass::class);\n\n\n\nBy default, the injector creates and uses an instance of\n\nZend\\Di\\DefaultContainer\n if no container is provided to it.  This\nimplementation is quite limited, however, and we recommend you use a more\nfeatureful container with the injector, such as\n\nzend-servicemanager\n.\nRefer to the \nUsage with PSR-11 containers\n\nand \nUsage with zend-servicemanager\n\nchapters for details.",
            "title": "Quick Start"
        },
        {
            "location": "/quick-start/#quick-start",
            "text": "The DI component provides an auto wiring strategy which implements constructor injection .  It utilizes  PSR-11  containers to obtain required services, so it\ncan be paired with any IoC container that implements this interface, such as zend-servicemanager .",
            "title": "Quick Start"
        },
        {
            "location": "/quick-start/#1-installation",
            "text": "If you haven't already,  install Composer .\nOnce you have, you can install zend-di:  $ composer install zendframework/zend-di",
            "title": "1. Installation"
        },
        {
            "location": "/quick-start/#2-configuring-the-injector",
            "text": "You can now create and configure an injector instance. The injector accepts an\ninstance of  Zend\\Di\\ConfigInterface . This can be provided by passing Zend\\Di\\Config , which accepts a PHP array to its constructor:  use Zend\\Di\\Injector;\nuse Zend\\Di\\Config;\n\n$injector = new Injector(new Config([\n    'preferences' => [\n        MyInterface::class => MyImplementation::class,\n    ],\n]));  This config implementation accepts a veriety of options. Refer to the Configuration  chapter for full details.",
            "title": "2. Configuring the injector"
        },
        {
            "location": "/quick-start/#3-creating-instances",
            "text": "Finally, you can create new instances of a specific class or alias by using the create()  method:  $instance = $injector->create(MyClass::class);  The only precondition is that the class you provide to  create()  must exist (or\nbe autoloadable).  If this is not the case, the injector will fail with an\nexception.  The  create()  method will  always  create a new instance of the given class. If\nyou need a shared instance, you can associate an IoC container implementing\nPSR-11 with the injector:  $injector = new Injector($config, $container);\n\n$sharedInstance = $injector->getContainer()->get(MyClass::class);  By default, the injector creates and uses an instance of Zend\\Di\\DefaultContainer  if no container is provided to it.  This\nimplementation is quite limited, however, and we recommend you use a more\nfeatureful container with the injector, such as zend-servicemanager .\nRefer to the  Usage with PSR-11 containers \nand  Usage with zend-servicemanager \nchapters for details.",
            "title": "3. Creating instances"
        },
        {
            "location": "/psr-11/",
            "text": "PSR-11 Support\n\n\nzend-di supports and implements \nPSR-11 ContainerInterface\n\nstarting in version 3. It supports any implementation to obtain instances for\nresolved dependencies.\n\n\nzend-di ships with a very basic implementation of the container interface which\nonly uses the injector to creates instances and always shares services it\ncreates. We suggest you replace it with another implementation such as\n\nzend-servicemanager\n for\nmore flexibility.",
            "title": "PSR-11 Support"
        },
        {
            "location": "/psr-11/#psr-11-support",
            "text": "zend-di supports and implements  PSR-11 ContainerInterface \nstarting in version 3. It supports any implementation to obtain instances for\nresolved dependencies.  zend-di ships with a very basic implementation of the container interface which\nonly uses the injector to creates instances and always shares services it\ncreates. We suggest you replace it with another implementation such as zend-servicemanager  for\nmore flexibility.",
            "title": "PSR-11 Support"
        },
        {
            "location": "/config/",
            "text": "Configuration\n\n\nConfiguration detailing how types are constructed and dependencies should be\nresolved can be provided as an associative array when instantiating\n\nZend\\Di\\Config\n. A type may be an actual class name or an alias to a class\nname.\n\n\nThe configuration array respects the following keys (unknown keys are ignored):\n\n\n\n\n\n\npreferences\n: Associative nested array that maps class or interface names to\n  a service name that should be used to provide a dependency. See the\n  \nType Preferences\n section below for details.\n\n\n\n\n\n\ntypes\n: Associative array defining how classes or aliases should be\n  constructed. Each key in this array is a class or alias name, and its value is\n  another associative array with the following keys:\n\n\n\n\n\n\npreferences\n: The same as \npreferences\n above, but only for the associated\n    class.\n\n\n\n\n\n\nparameters\n: Associative array declaring the values to inject for the\n    declared construction parameters.  Each key is the parameter name as\n    declared in the constructor method of the associated class name. See the\n    \nParameters\n section below for details.\n\n\n\n\n\n\ntypeOf\n: String that contains a class name. It declares that the\n    associated key is an alias of the given class name. This class must exist.\n    It cannot not be another alias.\n\n\n\n\n\n\nBelow is an example of injector configuration.\n\n\n$config = new \\Zend\\Di\\Config([\n    // Declares global preferences to use when resolving\n    // dependencies of the specified type\n    'preferences' => [\n        // A map of classname => preferred type\n        MyInterface::class => MyImplementation::class,\n    ],\n\n    // Declares how types should be constructed.\n    // This also allows declaring aliases of a specific class\n    'types' => [\n        ClassName::class => [\n            // Declaration in the same way as global preferences\n            // but these will aply when the type of the associated key\n            // should be instanciated\n            'preferences' => [],\n\n            // Constructor parameters to inject. This option will define\n            // the injections directly by the parameter name of the constructor\n            // used as key.\n            //\n            // If the parameter is type-hinted by a class/interface name, you can\n            // provide the injection by string. The injector will use the IoC\n            // container to obtain it.\n            'parameters' => [\n                'foo' => 'bar',\n            ],\n        ],\n\n        // Define an alias\n        'Alias.Name' => [\n            'typeOf' => ClassName::class,\n\n            'preferences' => [],\n            'parameters' => [],\n        ],\n    ],\n]);\n\n\n\nType Preferences\n\n\nIn many cases, you might be using interfaces as type hints as opposed to\nconcrete types. Even though type preferences are not limited to interfaces or\nabstract class names, they provide hints to the injector on how such types\nshould be resolved.\n\n\nThe resolver will look up the name finally passed to the container in the\nfollowing way (the first match will be used):\n\n\n\n\nThe preference defined in the type configuration of  the class if it satifies\n   the typehint (implements, extends, or typeOf).\n\n\nIf there is a global preference defined and it satisfies the typehint.\n\n\nUse the typehinted name directly.\n\n\n\n\n// Assume the following classes are declared:\n\ninterface FooInterface\n{}\n\nclass Foo implements FooInterface\n{}\n\nclass SpecialFoo implements FooInterface\n{}\n\nclass Bar\n{}\n\nclass MyClass\n{\n    public function __construct(FooInterface $foo)\n    {\n        // ...\n    }\n}\n\n// With the following configuration:\n\nuse Zend\\Di\\Injector;\nuse Zend\\Di\\Config;\n\n$injector = new Injector(new Config([\n    'preferences' => [\n        FooInterface::class => Foo::class,\n    ],\n    'types' => [\n        'MyClass.A' => [\n            'typeOf' => MyClass::class\n            'preferences' => [\n               FooInterface::class => SpecialFoo::class,,\n            ],\n        ],\n        'MyClass.B' => [\n            'typeOf' => MyClass::class\n            'preferences' => [\n               FooInterface::class => Bar::class,,\n            ],\n        ],\n    ],\n]);\n\n\n// The results are:\n$a = $injector->create(MyClass::class); // Constructed with Foo\n$b = $injector->create('MyClass.A'); // Constructed with SpecialFoo\n$c = $injector->create('MyClass.B'); // Constructed with Foo (since Bar does not satisfy FooInterface)\n\n\n\nParameters\n\n\nIn contrast to type preferences, the resolver will not perform checks if the\nprovided value satisfies the required type. It will be used directly to inject\nthe value.\n\n\nThere are several ways to define injections.\n\n\n\n\n\n\nAn IoC container service name as string: This is only possible if the required\n  type is a class or interface. For other types (scalars, \niterable\n,\n  \ncallable\n, etc) or typeless parameters, the string value is passed \nas is\n.\n\n\n\n\n\n\nAn instance of \nZend\\Di\\Resolver\\ValueInjection\n: Injects the value returned\n  by \ngetValue()\n as is.\n\n\n\n\n\n\nAn instance of \nZend\\Di\\Resolver\\TypeInjection\n: Obtains the injected value\n  from the IoC container by passing the return value of \ngetType()\n to the\n  container's \nget()\n method.\n\n\n\n\n\n\nThe string literal \n'*'\n: This requests the injector to ignore any previously\n  defined parameter and use the type preference resolution as described in\n  \nType Preferences\n.\n\n\n\n\n\n\nAny other value will be used as is and encapsulated in a\n  \nZend\\Di\\Resolver\\ValueInjection\n. If the provided value's type does not fit\n  the required parameter type, an exception is thrown.\n\n\n\n\n\n\nAliases\n\n\nAliases allow you to configure the same class with different construction\noptions. Aliases can directly be created with the injector or declared as type\npreferences.\n\n\nAn alias must refer to an actual class or an interface, therefore you cannot\ndeclare aliases for another alias.\n\n\nFor example the following the following class should be instantiated in two\ndifferent ways:\n\n\n// Assume the following classes are declared:\n\nclass Foo\n{}\n\nclass SpecialFoo extends Foo\n{}\n\nclass MyClass\n{\n    public function __construct(Foo $foo, string $bar)\n    {\n        // ...\n    }\n}\n\n// With the following injection config:\n\nuse Zend\\Di\\Injector;\nuse Zend\\Di\\Config;\n\n$injector = new Injector(new Config([\n    'types' => [\n        MyClass::class => [\n            'parameters' => [\n               'foo' => SpecialFoo::class,\n               'bar' => 'Stringvalue',\n            ],\n        ],\n        'MyClass.Alias' => [\n            'typeOf' => MyClass::class,\n            'parameters' => [\n               'foo' => '*',\n               'bar' => 'Stringvalue',\n            ],\n        ],\n    ],\n]);\n\n// The results are:\n$a = $injector->create(MyClass::class); // Constructed with SpecialFoo\n$b = $injector->create('MyClass.Alias'); // Constructed with Foo (since there are no type preferences for Foo)",
            "title": "Configuration"
        },
        {
            "location": "/config/#configuration",
            "text": "Configuration detailing how types are constructed and dependencies should be\nresolved can be provided as an associative array when instantiating Zend\\Di\\Config . A type may be an actual class name or an alias to a class\nname.  The configuration array respects the following keys (unknown keys are ignored):    preferences : Associative nested array that maps class or interface names to\n  a service name that should be used to provide a dependency. See the\n   Type Preferences  section below for details.    types : Associative array defining how classes or aliases should be\n  constructed. Each key in this array is a class or alias name, and its value is\n  another associative array with the following keys:    preferences : The same as  preferences  above, but only for the associated\n    class.    parameters : Associative array declaring the values to inject for the\n    declared construction parameters.  Each key is the parameter name as\n    declared in the constructor method of the associated class name. See the\n     Parameters  section below for details.    typeOf : String that contains a class name. It declares that the\n    associated key is an alias of the given class name. This class must exist.\n    It cannot not be another alias.    Below is an example of injector configuration.  $config = new \\Zend\\Di\\Config([\n    // Declares global preferences to use when resolving\n    // dependencies of the specified type\n    'preferences' => [\n        // A map of classname => preferred type\n        MyInterface::class => MyImplementation::class,\n    ],\n\n    // Declares how types should be constructed.\n    // This also allows declaring aliases of a specific class\n    'types' => [\n        ClassName::class => [\n            // Declaration in the same way as global preferences\n            // but these will aply when the type of the associated key\n            // should be instanciated\n            'preferences' => [],\n\n            // Constructor parameters to inject. This option will define\n            // the injections directly by the parameter name of the constructor\n            // used as key.\n            //\n            // If the parameter is type-hinted by a class/interface name, you can\n            // provide the injection by string. The injector will use the IoC\n            // container to obtain it.\n            'parameters' => [\n                'foo' => 'bar',\n            ],\n        ],\n\n        // Define an alias\n        'Alias.Name' => [\n            'typeOf' => ClassName::class,\n\n            'preferences' => [],\n            'parameters' => [],\n        ],\n    ],\n]);",
            "title": "Configuration"
        },
        {
            "location": "/config/#type-preferences",
            "text": "In many cases, you might be using interfaces as type hints as opposed to\nconcrete types. Even though type preferences are not limited to interfaces or\nabstract class names, they provide hints to the injector on how such types\nshould be resolved.  The resolver will look up the name finally passed to the container in the\nfollowing way (the first match will be used):   The preference defined in the type configuration of  the class if it satifies\n   the typehint (implements, extends, or typeOf).  If there is a global preference defined and it satisfies the typehint.  Use the typehinted name directly.   // Assume the following classes are declared:\n\ninterface FooInterface\n{}\n\nclass Foo implements FooInterface\n{}\n\nclass SpecialFoo implements FooInterface\n{}\n\nclass Bar\n{}\n\nclass MyClass\n{\n    public function __construct(FooInterface $foo)\n    {\n        // ...\n    }\n}\n\n// With the following configuration:\n\nuse Zend\\Di\\Injector;\nuse Zend\\Di\\Config;\n\n$injector = new Injector(new Config([\n    'preferences' => [\n        FooInterface::class => Foo::class,\n    ],\n    'types' => [\n        'MyClass.A' => [\n            'typeOf' => MyClass::class\n            'preferences' => [\n               FooInterface::class => SpecialFoo::class,,\n            ],\n        ],\n        'MyClass.B' => [\n            'typeOf' => MyClass::class\n            'preferences' => [\n               FooInterface::class => Bar::class,,\n            ],\n        ],\n    ],\n]);\n\n\n// The results are:\n$a = $injector->create(MyClass::class); // Constructed with Foo\n$b = $injector->create('MyClass.A'); // Constructed with SpecialFoo\n$c = $injector->create('MyClass.B'); // Constructed with Foo (since Bar does not satisfy FooInterface)",
            "title": "Type Preferences"
        },
        {
            "location": "/config/#parameters",
            "text": "In contrast to type preferences, the resolver will not perform checks if the\nprovided value satisfies the required type. It will be used directly to inject\nthe value.  There are several ways to define injections.    An IoC container service name as string: This is only possible if the required\n  type is a class or interface. For other types (scalars,  iterable ,\n   callable , etc) or typeless parameters, the string value is passed  as is .    An instance of  Zend\\Di\\Resolver\\ValueInjection : Injects the value returned\n  by  getValue()  as is.    An instance of  Zend\\Di\\Resolver\\TypeInjection : Obtains the injected value\n  from the IoC container by passing the return value of  getType()  to the\n  container's  get()  method.    The string literal  '*' : This requests the injector to ignore any previously\n  defined parameter and use the type preference resolution as described in\n   Type Preferences .    Any other value will be used as is and encapsulated in a\n   Zend\\Di\\Resolver\\ValueInjection . If the provided value's type does not fit\n  the required parameter type, an exception is thrown.",
            "title": "Parameters"
        },
        {
            "location": "/config/#aliases",
            "text": "Aliases allow you to configure the same class with different construction\noptions. Aliases can directly be created with the injector or declared as type\npreferences.  An alias must refer to an actual class or an interface, therefore you cannot\ndeclare aliases for another alias.  For example the following the following class should be instantiated in two\ndifferent ways:  // Assume the following classes are declared:\n\nclass Foo\n{}\n\nclass SpecialFoo extends Foo\n{}\n\nclass MyClass\n{\n    public function __construct(Foo $foo, string $bar)\n    {\n        // ...\n    }\n}\n\n// With the following injection config:\n\nuse Zend\\Di\\Injector;\nuse Zend\\Di\\Config;\n\n$injector = new Injector(new Config([\n    'types' => [\n        MyClass::class => [\n            'parameters' => [\n               'foo' => SpecialFoo::class,\n               'bar' => 'Stringvalue',\n            ],\n        ],\n        'MyClass.Alias' => [\n            'typeOf' => MyClass::class,\n            'parameters' => [\n               'foo' => '*',\n               'bar' => 'Stringvalue',\n            ],\n        ],\n    ],\n]);\n\n// The results are:\n$a = $injector->create(MyClass::class); // Constructed with SpecialFoo\n$b = $injector->create('MyClass.Alias'); // Constructed with Foo (since there are no type preferences for Foo)",
            "title": "Aliases"
        },
        {
            "location": "/injector/",
            "text": "Injector\n\n\nThe \nZend\\Di\\Injector\n is responsible for creating instances by providing the\ndependencies required by the class.\n\n\nThe dependencies are resolved by analyzing the constructor parameters of the\nrequested class via reflection. For parameters defined with a class or interface\ntypehint, the configured preferences are taken into account.\n\n\nA \nZend\\Di\\ConfigInterface\n can be provided to configure the injector.\nSee the \nConfiguration\n chapter for details.\n\n\nCreate instances\n\n\nInstances can be created by calling \ncreate()\n:\n\n\nuse Zend\\Di\\Injector;\n\n$injector = new Injector()\n$injector->create(MyClass::class);\n\n\n\nCreate instances with parameters\n\n\nYou can also pass construction parameters when calling create:\n\n\n$injector->create(MyDbAdapter::class, [\n    'username' => 'johndoe',\n]);\n\n\n\nParameters passed to \ncreate()\n will overwrite any configured injection for the\nrequested class.\n\n\nGenerally the following behavior applies for parameter values that are not\n\nValueInjection\n or \nTypeInjection\n instances:\n\n\n\n\nIf the parameter has a class/interface typehint:\n\n\nstring values will be wrapped into a \nTypeInjection\n instance\n\n\nobjects are wrapped into a \nValueInjection\n instance\n\n\n\n\neverything else will fail with an exception.\n\n\n\n\n\n\nIf the parameter has a scalar or pseudo-type typehint (e.g. string, int,\n  iterable, callable, etc ...), the value will be wrapped in a \nValueInjection\n.\n\n\n\n\n\n\nIf the parameter has no typehint at all, the value will be wrapped into a\n  \nValueInjection\n.\n\n\n\n\n\n\nExamples\n\n\n// Assume the following classes\nclass Foo\n{}\n\nclass SpecialFoo extends Foo\n{}\n\nclass Bar\n{\n    public function __construct(Foo $foo, $type = null)\n    {}\n}\n\n// Usage\nuse Zend\\Di\\Resolver\\ValueInjection;\nuse Zend\\Di\\Resolver\\TypeInjection;\n\n// Creates Bar with an instance of SpecialFoo from the IoC container:\n$injector->create(Bar::class, [\n    'foo' => SpecialFoo::class,\n]);\n\n// Creates Bar with the given instance of SpecialFoo bypassing the IoC\n// container:\n$injector->create(Bar::class, [\n    'foo' => ValueInjection(new SpecialFoo()),\n]);\n\n// Creates Bar with an instance of Foo and the string literal 'SpecialFoo' for\n// $type:\n$injector->create(Bar::class, [\n    'type' => SpecialFoo::class,\n]);\n\n// Creates Bar with an instance of Foo and an instance of SpecialFoo from the\n// IoC container for $type:\n$injector->create(Bar::class, [\n    'type' => new TypeInjection(SpecialFoo::class),\n]);\n\n\n\nRefer to the \nParameters section in the Configuration chapter\n\nfor all possibilities of how parameters can be declared.\n\n\nCheck if a type is creatable\n\n\nIf you uncertain whether or not the injector can create a specific type, you can\ntest it with the \ncanCreate()\n method.\n\n\nFor example, if you were to consume the class name in a generic service factory\nfor zend-servicemanager:\n\n\nuse Zend\\Di\\Injector;\n\n/** @var \\Zend\\ServiceManager\\ServiceManager $container */\n$factory = function($container, $requestedName, array $options = null) {\n    $injector = $container->get(Injector::class);\n\n    if (! $injector->canCreate($requestedName)) {\n        throw new \\RuntimeException('Bad service name');\n    }\n\n    return $injector->create($requestedName, $options? : []);\n};\n\n$serviceManager->setFactory('Foo', $factory);\n$serviceManager->setFactory('Bar', $factory);\n$serviceManager->setFactory(stdClass::class, $factory);",
            "title": "Injector"
        },
        {
            "location": "/injector/#injector",
            "text": "The  Zend\\Di\\Injector  is responsible for creating instances by providing the\ndependencies required by the class.  The dependencies are resolved by analyzing the constructor parameters of the\nrequested class via reflection. For parameters defined with a class or interface\ntypehint, the configured preferences are taken into account.  A  Zend\\Di\\ConfigInterface  can be provided to configure the injector.\nSee the  Configuration  chapter for details.",
            "title": "Injector"
        },
        {
            "location": "/injector/#create-instances",
            "text": "Instances can be created by calling  create() :  use Zend\\Di\\Injector;\n\n$injector = new Injector()\n$injector->create(MyClass::class);",
            "title": "Create instances"
        },
        {
            "location": "/injector/#create-instances-with-parameters",
            "text": "You can also pass construction parameters when calling create:  $injector->create(MyDbAdapter::class, [\n    'username' => 'johndoe',\n]);  Parameters passed to  create()  will overwrite any configured injection for the\nrequested class.  Generally the following behavior applies for parameter values that are not ValueInjection  or  TypeInjection  instances:   If the parameter has a class/interface typehint:  string values will be wrapped into a  TypeInjection  instance  objects are wrapped into a  ValueInjection  instance   everything else will fail with an exception.    If the parameter has a scalar or pseudo-type typehint (e.g. string, int,\n  iterable, callable, etc ...), the value will be wrapped in a  ValueInjection .    If the parameter has no typehint at all, the value will be wrapped into a\n   ValueInjection .",
            "title": "Create instances with parameters"
        },
        {
            "location": "/injector/#examples",
            "text": "// Assume the following classes\nclass Foo\n{}\n\nclass SpecialFoo extends Foo\n{}\n\nclass Bar\n{\n    public function __construct(Foo $foo, $type = null)\n    {}\n}\n\n// Usage\nuse Zend\\Di\\Resolver\\ValueInjection;\nuse Zend\\Di\\Resolver\\TypeInjection;\n\n// Creates Bar with an instance of SpecialFoo from the IoC container:\n$injector->create(Bar::class, [\n    'foo' => SpecialFoo::class,\n]);\n\n// Creates Bar with the given instance of SpecialFoo bypassing the IoC\n// container:\n$injector->create(Bar::class, [\n    'foo' => ValueInjection(new SpecialFoo()),\n]);\n\n// Creates Bar with an instance of Foo and the string literal 'SpecialFoo' for\n// $type:\n$injector->create(Bar::class, [\n    'type' => SpecialFoo::class,\n]);\n\n// Creates Bar with an instance of Foo and an instance of SpecialFoo from the\n// IoC container for $type:\n$injector->create(Bar::class, [\n    'type' => new TypeInjection(SpecialFoo::class),\n]);  Refer to the  Parameters section in the Configuration chapter \nfor all possibilities of how parameters can be declared.",
            "title": "Examples"
        },
        {
            "location": "/injector/#check-if-a-type-is-creatable",
            "text": "If you uncertain whether or not the injector can create a specific type, you can\ntest it with the  canCreate()  method.  For example, if you were to consume the class name in a generic service factory\nfor zend-servicemanager:  use Zend\\Di\\Injector;\n\n/** @var \\Zend\\ServiceManager\\ServiceManager $container */\n$factory = function($container, $requestedName, array $options = null) {\n    $injector = $container->get(Injector::class);\n\n    if (! $injector->canCreate($requestedName)) {\n        throw new \\RuntimeException('Bad service name');\n    }\n\n    return $injector->create($requestedName, $options? : []);\n};\n\n$serviceManager->setFactory('Foo', $factory);\n$serviceManager->setFactory('Bar', $factory);\n$serviceManager->setFactory(stdClass::class, $factory);",
            "title": "Check if a type is creatable"
        },
        {
            "location": "/codegen/",
            "text": "Code Generator\n\n\nzend-di comes with \nAhead-of-Time (AoT)\n\ngenerators to create optimized code for production. These generators will\ninspect the provided classes, resolve their dependencies, and generate factories\nbased on these results.\n\n\n\n\nRemoval of zend-code dependencies\n\n\nBefore version 3.1, this feature required \nzend-code\n,\nwhich you can add to your project using Composer:\n\n\n$ composer require --dev zendframework/zend-code\n\n\n\nSince version 3.1 and up, this is no longer required.\n\n\n\n\nGenerating an optimized injector\n\n\nThe \nZend\\Di\\CodeGenerator\\InjectorGenerator\n class offers an implementation to\ngenerate an optimized injector based on the runtime configuration and a resolver\ninstance.\n\n\nuse Zend\\Di\\Config;\nuse Zend\\Di\\Definition\\RuntimeDefinition;\nuse Zend\\Di\\Resolver\\DependencyResolver;\nuse Zend\\Di\\CodeGenerator\\InjectorGenerator;\n\n$config = new Config();\n$resolver = new DependencyResolver(new RuntimeDefinition(), $config)\n$generator = new InjectorGenerator($config, $resolver);\n\n// It is highly recommended to set the container that is used at runtime:\n$resolver->setContainer($container);\n$generator->setOutputDirectory('/path/to/generated/files');\n$generator->generate([\n    MyClassA::class,\n    MyClassB::class,\n    // ...\n]);\n\n\n\nYou can also utilize \nZend\\Code\\Scanner\n to scan your code for classes:\n\n\n$scanner = new DirectoryScanner(__DIR__);\n$generator->generate($scanner->getClassNames());\n\n\n\nMVC and Expressive integration\n\n\nWhen you are using zend-di's \nConfigProvider\n with Expressive or consuming the\n\nModule\n class via zend-mvc, you can obtain the generator instance from the\nservice manager:\n\n\n$generator = $serviceManager->get(\\Zend\\Di\\CodeGenerator\\InjectorGenerator::class);\n\n\n\nAoT Config Options\n\n\nThe service factory uses options in your \nconfig\n service, located under the key\n\ndependencies.auto.aot\n. This should be defined as an associative array of\noptions for creating the code generator instance. This array respects the\nfollowing keys (unknown keys are ignored):\n\n\n\n\n\n\nnamespace\n: This will be used as base namespace to prefix the namespace of\n  the generated classes.  It will be passed to the constructor of\n  \nZend\\Di\\CodeGenerator\\InjectorGenerator\n; the default value is\n  \nZend\\Di\\Generated\n.\n\n\n\n\n\n\ndirectory\n: The directory where the generated PHP files will be stored. If\n  this value is not provided, you will need to set it with the generator's\n  \nsetOutputDirectory()\n method before calling \ngenerate()\n.\n\n\n\n\n\n\nBelow is an example detailing configuration of the generator factory:\n\n\nreturn [\n    'dependencies' => [\n        'auto' => [\n            'aot' => [\n                'namespace' => 'AppAoT\\Generated',\n                'directory' => __DIR__ . '/../gen',\n            ],\n        ],\n    ],\n];\n\n\n\nLogging\n\n\nThe \nInjectorGenerator\n allows passing a \nPSR-3 logger\n instance\nvia an optional fourth constructor parameter.\n\n\nThe generator will log the following information:\n\n\n\n\nWhen a factory is about to be generated for a class or alias (Log level: Debug)\n\n\nWhen the factory generation caused an exception (Log level: Error)",
            "title": "Code Generator"
        },
        {
            "location": "/codegen/#code-generator",
            "text": "zend-di comes with  Ahead-of-Time (AoT) \ngenerators to create optimized code for production. These generators will\ninspect the provided classes, resolve their dependencies, and generate factories\nbased on these results.",
            "title": "Code Generator"
        },
        {
            "location": "/codegen/#removal-of-zend-code-dependencies",
            "text": "Before version 3.1, this feature required  zend-code ,\nwhich you can add to your project using Composer:  $ composer require --dev zendframework/zend-code  Since version 3.1 and up, this is no longer required.",
            "title": "Removal of zend-code dependencies"
        },
        {
            "location": "/codegen/#generating-an-optimized-injector",
            "text": "The  Zend\\Di\\CodeGenerator\\InjectorGenerator  class offers an implementation to\ngenerate an optimized injector based on the runtime configuration and a resolver\ninstance.  use Zend\\Di\\Config;\nuse Zend\\Di\\Definition\\RuntimeDefinition;\nuse Zend\\Di\\Resolver\\DependencyResolver;\nuse Zend\\Di\\CodeGenerator\\InjectorGenerator;\n\n$config = new Config();\n$resolver = new DependencyResolver(new RuntimeDefinition(), $config)\n$generator = new InjectorGenerator($config, $resolver);\n\n// It is highly recommended to set the container that is used at runtime:\n$resolver->setContainer($container);\n$generator->setOutputDirectory('/path/to/generated/files');\n$generator->generate([\n    MyClassA::class,\n    MyClassB::class,\n    // ...\n]);  You can also utilize  Zend\\Code\\Scanner  to scan your code for classes:  $scanner = new DirectoryScanner(__DIR__);\n$generator->generate($scanner->getClassNames());",
            "title": "Generating an optimized injector"
        },
        {
            "location": "/codegen/#mvc-and-expressive-integration",
            "text": "When you are using zend-di's  ConfigProvider  with Expressive or consuming the Module  class via zend-mvc, you can obtain the generator instance from the\nservice manager:  $generator = $serviceManager->get(\\Zend\\Di\\CodeGenerator\\InjectorGenerator::class);",
            "title": "MVC and Expressive integration"
        },
        {
            "location": "/codegen/#aot-config-options",
            "text": "The service factory uses options in your  config  service, located under the key dependencies.auto.aot . This should be defined as an associative array of\noptions for creating the code generator instance. This array respects the\nfollowing keys (unknown keys are ignored):    namespace : This will be used as base namespace to prefix the namespace of\n  the generated classes.  It will be passed to the constructor of\n   Zend\\Di\\CodeGenerator\\InjectorGenerator ; the default value is\n   Zend\\Di\\Generated .    directory : The directory where the generated PHP files will be stored. If\n  this value is not provided, you will need to set it with the generator's\n   setOutputDirectory()  method before calling  generate() .    Below is an example detailing configuration of the generator factory:  return [\n    'dependencies' => [\n        'auto' => [\n            'aot' => [\n                'namespace' => 'AppAoT\\Generated',\n                'directory' => __DIR__ . '/../gen',\n            ],\n        ],\n    ],\n];",
            "title": "AoT Config Options"
        },
        {
            "location": "/codegen/#logging",
            "text": "The  InjectorGenerator  allows passing a  PSR-3 logger  instance\nvia an optional fourth constructor parameter.  The generator will log the following information:   When a factory is about to be generated for a class or alias (Log level: Debug)  When the factory generation caused an exception (Log level: Error)",
            "title": "Logging"
        },
        {
            "location": "/v2/definitions/",
            "text": "Dependency Definitions\n\n\n\n\nVersion 2\n\n\nThis is documentation for the legacy version (2.x) of zend-di.\n\n\n\n\nDefinitions are what zend-di uses to understand the structure of the code it is\nattempting to wire. This means that if you've written non-ambiguous, clear, and\nconcise code, zend-di has a very good chance of understanding how to wire things\nup without much added complexity.\n\n\nDefinitionList\n\n\nDefinitions are introduced to the \nZend\\Di\\Di\n object through a definition list\nimplemented as \nZend\\Di\\DefinitionList\n (which extends \nSplDoublyLinkedList\n).\nOrder is important. Definitions in the front of the list will be consulted on a\nclass before definitions at the end of the list.\n\n\n\n\nAutoloading\n\n\nRegardless of what kind of \nDefinitionList\n strategy you decide to use, it is\nimportant that your autoloaders are already setup and ready to use.\n\n\n\n\nRuntimeDefinition\n\n\nThe default \nDefinitionList\n instantiated by \nZend\\Di\\Di\n when no other\nDefinitionList is provided is \nZend\\Di\\Definition\\RuntimeDefinition\n. The\n\nRuntimeDefinition\n will respond to queries about classes by using PHP's\nReflection API. The \nRuntimeDefinition\n uses any available information inside\nmethods \u2014 including their signature, the names of parameters, the\ntype-hints of the parameters, and the default values \u2014 to determine if\nsomething is optional or required when making a call to that method. The more\nexplicit you can be in your method naming and method signatures, the more likely\n\nZend\\Di\\Definition\\RuntimeDefinition\n will accurately understand the structure\nof your code.\n\n\nThe constructor of \nRuntimeDefinition\n looks like the following:\n\n\npublic function __construct(\n    IntrospectionStrategy $introspectionStrategy = null,\n    array $explicitClasses = null\n) {\n    $this->introspectionStrategy = $introspectionStrategy ?: new IntrospectionStrategy();\n    if ($explicitClasses) {\n        $this->setExplicitClasses($explicitClasses);\n    }\n}\n\n\n\nThe \nIntrospectionStrategy\n object is an object that defines the rules by which\nthe \nRuntimeDefinition\n will introspect information about your classes. Here are\nthe things it knows how to do:\n\n\n\n\n\n\nWhether or not to use annotations (scanning and parsing annotations is\n  expensive, and thus disabled by default).\n\n\n\n\n\n\nWhich method names to include in the introspection; this is a list of\n  patterns. By default, it registers the pattern \n/^set\\[A-Z\\]{1}\\\\w\\*/\n.\n\n\n\n\n\n\nWhich interface names represent the interface injection pattern; this is a\n  list of patterns. By default, the pattern \n/\\\\w\\*Aware\\\\w\\*/\n is registered.\n\n\n\n\n\n\nThe constructor for the \nIntrospectionStrategy\n looks like this:\n\n\npublic function __construct(AnnotationManager $annotationManager = null)\n{\n    $this->annotationManager = $annotationManager ?: $this->createDefaultAnnotationManager();\n}\n\n\n\nThe \nAnnotationManager\n is not required. If you wish to create a special\n\nAnnotationManager\n with your own annotations, and also wish to extend the\n\nRuntimeDefinition\n to look for those annotations, this is the place to do it.\n\n\nThe \nRuntimeDefinition\n also can be used to look up either all classes\n(implicitly, which is default), or explicitly look up for particular pre-defined\nclasses. This is useful when your strategy for inspecting one set of classes\nmight differ from those of another strategy for another set of classes. This can\nbe achieved by using the \nsetExplicitClasses()\n method or by passing a list of\nclasses as the second constructor argument of the \nRuntimeDefinition\n.\n\n\nCompilerDefinition\n\n\nThe \nCompilerDefinition\n is similar in nature to the \nRuntimeDefinition\n with\nthe exception that it can be seeded with more information for the purposes of\n\"compiling\" a definition. Compiled definitions eliminate reflection calls and\nannotation scannning, which can be a performance bottleneck in your production\napplications.\n\n\nFor example, let's assume we want to create a script that will create\ndefinitions for some of our library code:\n\n\n// in \"package name\" format\n$components = [\n    'My_MovieApp',\n    'My_OtherClasses',\n];\n\nforeach ($components as $component) {\n    $diCompiler = new Zend\\Di\\Definition\\CompilerDefinition;\n    $diCompiler->addDirectory('/path/to/classes/' . str_replace('_', '/', $component));\n\n    $diCompiler->compile();\n    file_put_contents(\n        __DIR__ . '/../data/di/' . $component . '-definition.php',\n        '<?php return ' . var_export($diCompiler->toArrayDefinition()->toArray(), true) . ';'\n    );\n}\n\n\n\nThe above creates a file for each \"package\", containing the full definition for\nthe classes defined for each. To utilize this in an application, use the\nfollowing:\n\n\nprotected function setupDi(Application $app)\n{\n    $definitionList = new DefinitionList([\n        new Definition\\ArrayDefinition(include __DIR__ .  '/path/to/data/di/My_MovieApp-definition.php'),\n        new Definition\\ArrayDefinition(include __DIR__ .  '/path/to/data/di/My_OtherClasses-definition.php'),\n        $runtime = new Definition\\RuntimeDefinition(),\n    ]);\n    $di = new Di($definitionList, null, new Config($this->config->di));\n    $di->instanceManager()->addTypePreference('Zend\\Di\\LocatorInterface', $di);\n    $app->setLocator($di);\n}\n\n\n\nThe above code would more than likely go inside your application's bootstrap or\nwithin a \nModule\n class. This represents the simplest and most performant way\nof configuring your DiC for usage.\n\n\nClassDefinition\n\n\nThe idea behind using a \nClassDefinition\n is two-fold. First, you may want to\noverride some information inside of a \nRuntimeDefinition\n. Secondly, you might\nwant to simply define your complete class's definition with an xml, ini, or php\nfile describing the structure. This class definition can be fed in via\n\nConfiguration\n or by directly instantiating and registering the \nDefinition\n\nwith the \nDefinitionList\n.\n\n\n(@todo - example)",
            "title": "Definitions"
        },
        {
            "location": "/v2/definitions/#dependency-definitions",
            "text": "",
            "title": "Dependency Definitions"
        },
        {
            "location": "/v2/definitions/#version-2",
            "text": "This is documentation for the legacy version (2.x) of zend-di.   Definitions are what zend-di uses to understand the structure of the code it is\nattempting to wire. This means that if you've written non-ambiguous, clear, and\nconcise code, zend-di has a very good chance of understanding how to wire things\nup without much added complexity.",
            "title": "Version 2"
        },
        {
            "location": "/v2/definitions/#definitionlist",
            "text": "Definitions are introduced to the  Zend\\Di\\Di  object through a definition list\nimplemented as  Zend\\Di\\DefinitionList  (which extends  SplDoublyLinkedList ).\nOrder is important. Definitions in the front of the list will be consulted on a\nclass before definitions at the end of the list.",
            "title": "DefinitionList"
        },
        {
            "location": "/v2/definitions/#autoloading",
            "text": "Regardless of what kind of  DefinitionList  strategy you decide to use, it is\nimportant that your autoloaders are already setup and ready to use.",
            "title": "Autoloading"
        },
        {
            "location": "/v2/definitions/#runtimedefinition",
            "text": "The default  DefinitionList  instantiated by  Zend\\Di\\Di  when no other\nDefinitionList is provided is  Zend\\Di\\Definition\\RuntimeDefinition . The RuntimeDefinition  will respond to queries about classes by using PHP's\nReflection API. The  RuntimeDefinition  uses any available information inside\nmethods \u2014 including their signature, the names of parameters, the\ntype-hints of the parameters, and the default values \u2014 to determine if\nsomething is optional or required when making a call to that method. The more\nexplicit you can be in your method naming and method signatures, the more likely Zend\\Di\\Definition\\RuntimeDefinition  will accurately understand the structure\nof your code.  The constructor of  RuntimeDefinition  looks like the following:  public function __construct(\n    IntrospectionStrategy $introspectionStrategy = null,\n    array $explicitClasses = null\n) {\n    $this->introspectionStrategy = $introspectionStrategy ?: new IntrospectionStrategy();\n    if ($explicitClasses) {\n        $this->setExplicitClasses($explicitClasses);\n    }\n}  The  IntrospectionStrategy  object is an object that defines the rules by which\nthe  RuntimeDefinition  will introspect information about your classes. Here are\nthe things it knows how to do:    Whether or not to use annotations (scanning and parsing annotations is\n  expensive, and thus disabled by default).    Which method names to include in the introspection; this is a list of\n  patterns. By default, it registers the pattern  /^set\\[A-Z\\]{1}\\\\w\\*/ .    Which interface names represent the interface injection pattern; this is a\n  list of patterns. By default, the pattern  /\\\\w\\*Aware\\\\w\\*/  is registered.    The constructor for the  IntrospectionStrategy  looks like this:  public function __construct(AnnotationManager $annotationManager = null)\n{\n    $this->annotationManager = $annotationManager ?: $this->createDefaultAnnotationManager();\n}  The  AnnotationManager  is not required. If you wish to create a special AnnotationManager  with your own annotations, and also wish to extend the RuntimeDefinition  to look for those annotations, this is the place to do it.  The  RuntimeDefinition  also can be used to look up either all classes\n(implicitly, which is default), or explicitly look up for particular pre-defined\nclasses. This is useful when your strategy for inspecting one set of classes\nmight differ from those of another strategy for another set of classes. This can\nbe achieved by using the  setExplicitClasses()  method or by passing a list of\nclasses as the second constructor argument of the  RuntimeDefinition .",
            "title": "RuntimeDefinition"
        },
        {
            "location": "/v2/definitions/#compilerdefinition",
            "text": "The  CompilerDefinition  is similar in nature to the  RuntimeDefinition  with\nthe exception that it can be seeded with more information for the purposes of\n\"compiling\" a definition. Compiled definitions eliminate reflection calls and\nannotation scannning, which can be a performance bottleneck in your production\napplications.  For example, let's assume we want to create a script that will create\ndefinitions for some of our library code:  // in \"package name\" format\n$components = [\n    'My_MovieApp',\n    'My_OtherClasses',\n];\n\nforeach ($components as $component) {\n    $diCompiler = new Zend\\Di\\Definition\\CompilerDefinition;\n    $diCompiler->addDirectory('/path/to/classes/' . str_replace('_', '/', $component));\n\n    $diCompiler->compile();\n    file_put_contents(\n        __DIR__ . '/../data/di/' . $component . '-definition.php',\n        '<?php return ' . var_export($diCompiler->toArrayDefinition()->toArray(), true) . ';'\n    );\n}  The above creates a file for each \"package\", containing the full definition for\nthe classes defined for each. To utilize this in an application, use the\nfollowing:  protected function setupDi(Application $app)\n{\n    $definitionList = new DefinitionList([\n        new Definition\\ArrayDefinition(include __DIR__ .  '/path/to/data/di/My_MovieApp-definition.php'),\n        new Definition\\ArrayDefinition(include __DIR__ .  '/path/to/data/di/My_OtherClasses-definition.php'),\n        $runtime = new Definition\\RuntimeDefinition(),\n    ]);\n    $di = new Di($definitionList, null, new Config($this->config->di));\n    $di->instanceManager()->addTypePreference('Zend\\Di\\LocatorInterface', $di);\n    $app->setLocator($di);\n}  The above code would more than likely go inside your application's bootstrap or\nwithin a  Module  class. This represents the simplest and most performant way\nof configuring your DiC for usage.",
            "title": "CompilerDefinition"
        },
        {
            "location": "/v2/definitions/#classdefinition",
            "text": "The idea behind using a  ClassDefinition  is two-fold. First, you may want to\noverride some information inside of a  RuntimeDefinition . Secondly, you might\nwant to simply define your complete class's definition with an xml, ini, or php\nfile describing the structure. This class definition can be fed in via Configuration  or by directly instantiating and registering the  Definition \nwith the  DefinitionList .  (@todo - example)",
            "title": "ClassDefinition"
        },
        {
            "location": "/v2/instance-manager/",
            "text": "Instance Manager\n\n\n\n\nVersion 2\n\n\nThis is documentation for the legacy version (2.x) of zend-di.\n\n\n\n\nThe \nInstanceManager\n is responsible for any runtime information associated with\nthe zend-di DiC.  This means that the information that goes into the instance\nmanager is specific to both how the particular consuming application's needs,\nand even more specifically to the environment in which the application is\nrunning.\n\n\nParameters\n\n\nParameters are simply entry points for either dependencies or instance\nconfiguration values. A class consists of a set of parameters, each uniquely\nnamed. When writing your classes, you should attempt to not use the same\nparameter name twice in the same class when you expect that that parameters is\nused for either instance configuration or an object dependency. This leads to an\nambiguous parameter, and is a situation best avoided.\n\n\nOur movie finder example can be further used to explain these concepts:\n\n\nnamespace MyLibrary\n{\n    class DbAdapter\n    {\n        protected $username = null;\n        protected $password = null;\n\n        public function __construct($username, $password)\n        {\n            $this->username = $username;\n            $this->password = $password;\n        }\n    }\n}\n\nnamespace MyMovieApp\n{\n    class MovieFinder\n    {\n        protected $dbAdapter = null;\n\n        public function __construct(\\MyLibrary\\DbAdapter $dbAdapter)\n        {\n            $this->dbAdapter = $dbAdapter;\n        }\n    }\n\n    class MovieLister\n    {\n        protected $movieFinder = null;\n\n        public function __construct(MovieFinder $movieFinder)\n        {\n            $this->movieFinder = $movieFinder;\n        }\n    }\n}\n\n\n\nIn the above example, the class \nDbAdapter\n has 2 parameters: \nusername\n and\n\npassword\n; \nMovieFinder\n has one parameter: \ndbAdapter\n; and \nMovieLister\n has\none parameter: \nmovieFinder\n. Any of these can be utilized for injection of\neither dependencies or scalar values during instance configuration or during\ncall time.\n\n\nWhen looking at the above code, since the \n$dbAdapter\n parameter and the\n\n$movieFinder\n parameter are both type-hinted with concrete types, the DiC can\nassume that it can fulfill these object tendencies by itself. On the other hand,\n\n$username\n and \n$password\n do not have type-hints and are, more than likely,\nscalar in nature. Since the DiC cannot reasonably know this information, it must\nbe provided to the instance manager in the form of parameters. Not doing so will\nforce \n$di->get('MyMovieApp\\\\MovieLister')\n to throw an exception.\n\n\nThe following ways of using parameters are available:\n\n\n// Setting instance configuration into the instance manager:\n$di->instanceManager()->setParameters('MyLibrary\\DbAdapter', [\n    'username' => 'myusername',\n    'password' => 'mypassword',\n]);\n\n// Forcing a particular dependency to be used by the instance manager:\n$di->instanceManager()->setParameters('MyMovieApp\\MovieFinder', [\n    'dbAdapter' => new MyLibrary\\DbAdapter('myusername', 'mypassword'),\n]);\n\n// Passing instance parameters at call time:\n$movieLister = $di->get('MyMovieApp\\MovieLister', [\n    'username' => $config->username,\n    'password' => $config->password,\n]);\n\n// Passing a specific instance at call time:\n$movieLister = $di->get('MyMovieApp\\MovieLister', [\n    'dbAdapter' => new MyLibrary\\DbAdapter('myusername', 'mypassword'),\n]);\n\n\n\nPreferences\n\n\nIn many cases, you might be using interfaces as type hints as opposed to\nconcrete types. Lets assume the movie example was modified in the following way:\n\n\nnamespace MyMovieApp\n{\n    interface MovieFinderInterface\n    {\n        // methods required for this type\n    }\n\n    class GenericMovieFinder implements MovieFinderInterface\n    {\n        protected $dbAdapter = null;\n\n        public function __construct(\\MyLibrary\\DbAdapter $dbAdapter)\n        {\n            $this->dbAdapter = $dbAdapter;\n        }\n    }\n\n    class MovieLister\n    {\n        protected $movieFinder = null;\n\n        public function __construct(MovieFinderInterface $movieFinder)\n        {\n            $this->movieFinder = $movieFinder;\n        }\n    }\n}\n\n\n\nWhat you'll notice above is that the \nMovieLister\n type now expects that the\ndependency injected implements the \nMovieFinderInterface\n. This allows multiple\nimplementations of this base interface to be used as a dependency, if that is\nwhat the consumer decides they want to do. As you can imagine, zend-di, by\nitself would not be able to determine what kind of concrete object to use\nfulfill this dependency, so this type of \"preference\" needs to be made known to\nthe instance manager.\n\n\nTo give this information to the instance manager, see the following code\nexample:\n\n\n$di->instanceManager()->addTypePreference(\n    \\MyMovieApp\\MovieFinderInterface::class,\n    \\MyMovieApp\\GenericMovieFinder::class\n);\n\n// Assuming all instance config for username, password is setup:\n$di->get(\\MyMovieApp\\MovieLister::class);\n\n\n\nAliases\n\n\nIn some situations, you'll find that you need to alias an instance. There are\ntwo main reasons to do this. First, it creates a simpler, alternative name to\nuse when using the DiC, as opposed to using the full class name. Second, you\nmight find that you need to have the same object type in two separate contexts.\nThis means that when you alias a particular class, you can then attach a\nspecific instance configuration to that alias, as opposed to attaching that\nconfiguration to the class name.\n\n\nTo demonstrate both of these points, we'll look at a use case where we'll have\ntwo separate database adapters. One will be for read-only operations, the other\nwill be for read-write operations.\n\n\n\n\nAlias parameters\n\n\nAliases can also have parameters registered at alias time.\n\n\n\n\n// Assume the MovieLister example of code from the quick start.\n\n$im = $di->instanceManager();\n\n// add alias for short naming\n$im->addAlias('movielister', 'MyMovieApp\\MovieLister');\n\n// add aliases for specific instances\n$im->addAlias('dbadapter-readonly', 'MyLibrary\\DbAdapter', [\n    'username' => $config->db->readAdapter->username,\n    'password' => $config->db->readAdapter->password,\n]);\n$im->addAlias('dbadapter-readwrite', 'MyLibrary\\DbAdapter', [\n    'username' => $config->db->readWriteAdapter->username,\n    'password' => $config->db->readWriteAdapter->password,\n]);\n\n// set a default type to use, pointing to an alias\n$im->addTypePreference('MyLibrary\\DbAdapter', 'dbadapter-readonly');\n\n$movieListerRead = $di->get('MyMovieApp\\MovieLister');\n$movieListerReadWrite = $di->get('MyMovieApp\\MovieLister', [\n    'dbAdapter' => 'dbadapter-readwrite',\n]);",
            "title": "Instance Manager"
        },
        {
            "location": "/v2/instance-manager/#instance-manager",
            "text": "",
            "title": "Instance Manager"
        },
        {
            "location": "/v2/instance-manager/#version-2",
            "text": "This is documentation for the legacy version (2.x) of zend-di.   The  InstanceManager  is responsible for any runtime information associated with\nthe zend-di DiC.  This means that the information that goes into the instance\nmanager is specific to both how the particular consuming application's needs,\nand even more specifically to the environment in which the application is\nrunning.",
            "title": "Version 2"
        },
        {
            "location": "/v2/instance-manager/#parameters",
            "text": "Parameters are simply entry points for either dependencies or instance\nconfiguration values. A class consists of a set of parameters, each uniquely\nnamed. When writing your classes, you should attempt to not use the same\nparameter name twice in the same class when you expect that that parameters is\nused for either instance configuration or an object dependency. This leads to an\nambiguous parameter, and is a situation best avoided.  Our movie finder example can be further used to explain these concepts:  namespace MyLibrary\n{\n    class DbAdapter\n    {\n        protected $username = null;\n        protected $password = null;\n\n        public function __construct($username, $password)\n        {\n            $this->username = $username;\n            $this->password = $password;\n        }\n    }\n}\n\nnamespace MyMovieApp\n{\n    class MovieFinder\n    {\n        protected $dbAdapter = null;\n\n        public function __construct(\\MyLibrary\\DbAdapter $dbAdapter)\n        {\n            $this->dbAdapter = $dbAdapter;\n        }\n    }\n\n    class MovieLister\n    {\n        protected $movieFinder = null;\n\n        public function __construct(MovieFinder $movieFinder)\n        {\n            $this->movieFinder = $movieFinder;\n        }\n    }\n}  In the above example, the class  DbAdapter  has 2 parameters:  username  and password ;  MovieFinder  has one parameter:  dbAdapter ; and  MovieLister  has\none parameter:  movieFinder . Any of these can be utilized for injection of\neither dependencies or scalar values during instance configuration or during\ncall time.  When looking at the above code, since the  $dbAdapter  parameter and the $movieFinder  parameter are both type-hinted with concrete types, the DiC can\nassume that it can fulfill these object tendencies by itself. On the other hand, $username  and  $password  do not have type-hints and are, more than likely,\nscalar in nature. Since the DiC cannot reasonably know this information, it must\nbe provided to the instance manager in the form of parameters. Not doing so will\nforce  $di->get('MyMovieApp\\\\MovieLister')  to throw an exception.  The following ways of using parameters are available:  // Setting instance configuration into the instance manager:\n$di->instanceManager()->setParameters('MyLibrary\\DbAdapter', [\n    'username' => 'myusername',\n    'password' => 'mypassword',\n]);\n\n// Forcing a particular dependency to be used by the instance manager:\n$di->instanceManager()->setParameters('MyMovieApp\\MovieFinder', [\n    'dbAdapter' => new MyLibrary\\DbAdapter('myusername', 'mypassword'),\n]);\n\n// Passing instance parameters at call time:\n$movieLister = $di->get('MyMovieApp\\MovieLister', [\n    'username' => $config->username,\n    'password' => $config->password,\n]);\n\n// Passing a specific instance at call time:\n$movieLister = $di->get('MyMovieApp\\MovieLister', [\n    'dbAdapter' => new MyLibrary\\DbAdapter('myusername', 'mypassword'),\n]);",
            "title": "Parameters"
        },
        {
            "location": "/v2/instance-manager/#preferences",
            "text": "In many cases, you might be using interfaces as type hints as opposed to\nconcrete types. Lets assume the movie example was modified in the following way:  namespace MyMovieApp\n{\n    interface MovieFinderInterface\n    {\n        // methods required for this type\n    }\n\n    class GenericMovieFinder implements MovieFinderInterface\n    {\n        protected $dbAdapter = null;\n\n        public function __construct(\\MyLibrary\\DbAdapter $dbAdapter)\n        {\n            $this->dbAdapter = $dbAdapter;\n        }\n    }\n\n    class MovieLister\n    {\n        protected $movieFinder = null;\n\n        public function __construct(MovieFinderInterface $movieFinder)\n        {\n            $this->movieFinder = $movieFinder;\n        }\n    }\n}  What you'll notice above is that the  MovieLister  type now expects that the\ndependency injected implements the  MovieFinderInterface . This allows multiple\nimplementations of this base interface to be used as a dependency, if that is\nwhat the consumer decides they want to do. As you can imagine, zend-di, by\nitself would not be able to determine what kind of concrete object to use\nfulfill this dependency, so this type of \"preference\" needs to be made known to\nthe instance manager.  To give this information to the instance manager, see the following code\nexample:  $di->instanceManager()->addTypePreference(\n    \\MyMovieApp\\MovieFinderInterface::class,\n    \\MyMovieApp\\GenericMovieFinder::class\n);\n\n// Assuming all instance config for username, password is setup:\n$di->get(\\MyMovieApp\\MovieLister::class);",
            "title": "Preferences"
        },
        {
            "location": "/v2/instance-manager/#aliases",
            "text": "In some situations, you'll find that you need to alias an instance. There are\ntwo main reasons to do this. First, it creates a simpler, alternative name to\nuse when using the DiC, as opposed to using the full class name. Second, you\nmight find that you need to have the same object type in two separate contexts.\nThis means that when you alias a particular class, you can then attach a\nspecific instance configuration to that alias, as opposed to attaching that\nconfiguration to the class name.  To demonstrate both of these points, we'll look at a use case where we'll have\ntwo separate database adapters. One will be for read-only operations, the other\nwill be for read-write operations.",
            "title": "Aliases"
        },
        {
            "location": "/v2/instance-manager/#alias-parameters",
            "text": "Aliases can also have parameters registered at alias time.   // Assume the MovieLister example of code from the quick start.\n\n$im = $di->instanceManager();\n\n// add alias for short naming\n$im->addAlias('movielister', 'MyMovieApp\\MovieLister');\n\n// add aliases for specific instances\n$im->addAlias('dbadapter-readonly', 'MyLibrary\\DbAdapter', [\n    'username' => $config->db->readAdapter->username,\n    'password' => $config->db->readAdapter->password,\n]);\n$im->addAlias('dbadapter-readwrite', 'MyLibrary\\DbAdapter', [\n    'username' => $config->db->readWriteAdapter->username,\n    'password' => $config->db->readWriteAdapter->password,\n]);\n\n// set a default type to use, pointing to an alias\n$im->addTypePreference('MyLibrary\\DbAdapter', 'dbadapter-readonly');\n\n$movieListerRead = $di->get('MyMovieApp\\MovieLister');\n$movieListerReadWrite = $di->get('MyMovieApp\\MovieLister', [\n    'dbAdapter' => 'dbadapter-readwrite',\n]);",
            "title": "Alias parameters"
        },
        {
            "location": "/v2/config/",
            "text": "Configuration\n\n\n\n\nVersion 2\n\n\nThis is documentation for the legacy version (2.x) of zend-di.\n\n\n\n\nMost of the configuration for both the setup of \nDefinition\ns as well as the\nsetup of the \nInstanceManager\n can be attained by a configuration file. This\nfile will produce an array (typically) and have an iterable structure.\n\n\nThe top two keys are 'definition' and 'instance', each specifying values for\nthe definition setup and instance manager setup, respectively.\n\n\nThe definition section expects the following information expressed as a PHP\narray:\n\n\n$config = [\n    'definition' => [\n        'compiler' => [/* @todo compiler information */],\n        'runtime'  => [/* @todo runtime information */],\n        'class' => [\n            'instantiator' => '', // the name of the instantiator, by default this is __construct\n            'supertypes'   => [], // an array of supertypes the class implements\n            'methods'      => [\n                'setSomeParameter' => [ // a method name\n                    'parameterName' => [\n                        'name',        // string parameter name\n                        'type',        // type or null\n                        'is-required', // bool\n                    ],\n                ],\n            ],\n        ],\n    ],\n];",
            "title": "Configuration"
        },
        {
            "location": "/v2/config/#configuration",
            "text": "",
            "title": "Configuration"
        },
        {
            "location": "/v2/config/#version-2",
            "text": "This is documentation for the legacy version (2.x) of zend-di.   Most of the configuration for both the setup of  Definition s as well as the\nsetup of the  InstanceManager  can be attained by a configuration file. This\nfile will produce an array (typically) and have an iterable structure.  The top two keys are 'definition' and 'instance', each specifying values for\nthe definition setup and instance manager setup, respectively.  The definition section expects the following information expressed as a PHP\narray:  $config = [\n    'definition' => [\n        'compiler' => [/* @todo compiler information */],\n        'runtime'  => [/* @todo runtime information */],\n        'class' => [\n            'instantiator' => '', // the name of the instantiator, by default this is __construct\n            'supertypes'   => [], // an array of supertypes the class implements\n            'methods'      => [\n                'setSomeParameter' => [ // a method name\n                    'parameterName' => [\n                        'name',        // string parameter name\n                        'type',        // type or null\n                        'is-required', // bool\n                    ],\n                ],\n            ],\n        ],\n    ],\n];",
            "title": "Version 2"
        },
        {
            "location": "/v2/debugging-and-complex-use-cases/",
            "text": "Debugging & Complex Use Cases\n\n\n\n\nVersion 2\n\n\nThis is documentation for the legacy version (2.x) of zend-di.\n\n\n\n\nDebugging a DiC\n\n\nIt is possible to dump the information contained within both the \nDefinition\n\nand \nInstanceManager\n for a \nZend\\Di\\Di\n instance.\n\n\nThe easiest way is to do the following:\n\n\nZend\\Di\\Display\\Console::export($di);\n\n\n\nIf you are using a \nRuntimeDefinition\n where upon you expect a particular\ndefinition to be resolve at the first-call, you can see that information to the\nconsole display to force it to read that class:\n\n\nZend\\Di\\Display\\Console::export($di, ['A\\ClassIWantTo\\GetTheDefinitionFor']);\n\n\n\nComplex Use Cases\n\n\nInterface Injection\n\n\nnamespace Foo\\Bar\n{\n    class Baz implements BamAwareInterface\n    {\n        public $bam;\n\n        public function setBam(Bam $bam)\n        {\n            $this->bam = $bam;\n        }\n    }\n\n    class Bam\n    {\n    }\n\n    interface BamAwareInterface\n    {\n        public function setBam(Bam $bam);\n    }\n}\n\nnamespace {\n    include 'zf2bootstrap.php';\n    $di = new Zend\\Di\\Di;\n    $baz = $di->get('Foo\\Bar\\Baz');\n}\n\n\n\nSetter Injection with Class Definition\n\n\nnamespace Foo\\Bar\n{\n    class Baz\n    {\n        public $bam;\n\n        public function setBam(Bam $bam)\n        {\n            $this->bam = $bam;\n        }\n    }\n\n    class Bam {\n    }\n}\n\nnamespace {\n    $di = new Zend\\Di\\Di;\n    $di->configure(new Zend\\Di\\Config([\n        'definition' => [\n            'class' => [\n                'Foo\\Bar\\Baz' => [\n                    'setBam' => ['required' => true],\n                ],\n            ],\n        ],\n    ]));\n    $baz = $di->get('Foo\\Bar\\Baz');\n}\n\n\n\nMultiple Injections To A Single Injection Point\n\n\nnamespace Application\n{\n    class Page\n    {\n        public $blocks;\n\n        public function addBlock(Block $block)\n        {\n            $this->blocks[] = $block;\n        }\n    }\n\n    interface Block\n    {\n    }\n}\n\nnamespace MyModule {\n    class BlockOne implements \\Application\\Block {}\n    class BlockTwo implements \\Application\\Block {}\n}\n\nnamespace {\n    include 'zf2bootstrap.php';\n    $di = new Zend\\Di\\Di;\n    $di->configure(new Zend\\Di\\Config([\n        'definition' => [\n            'class' => [\n                'Application\\Page' => [\n                    'addBlock' => [\n                        'block' => [\n                            'type' => 'Application\\Block',\n                            'required' => true,\n                        ],\n                    ],\n                ],\n            ],\n        ],\n        'instance' => [\n            'Application\\Page' => [\n                'injections' => [\n                    'MyModule\\BlockOne',\n                    'MyModule\\BlockTwo',\n                ],\n            ],\n        ],\n    ]));\n    $page = $di->get('Application\\Page');\n}",
            "title": "Debugging And Complex Use Cases"
        },
        {
            "location": "/v2/debugging-and-complex-use-cases/#debugging-complex-use-cases",
            "text": "",
            "title": "Debugging &amp; Complex Use Cases"
        },
        {
            "location": "/v2/debugging-and-complex-use-cases/#version-2",
            "text": "This is documentation for the legacy version (2.x) of zend-di.",
            "title": "Version 2"
        },
        {
            "location": "/v2/debugging-and-complex-use-cases/#debugging-a-dic",
            "text": "It is possible to dump the information contained within both the  Definition \nand  InstanceManager  for a  Zend\\Di\\Di  instance.  The easiest way is to do the following:  Zend\\Di\\Display\\Console::export($di);  If you are using a  RuntimeDefinition  where upon you expect a particular\ndefinition to be resolve at the first-call, you can see that information to the\nconsole display to force it to read that class:  Zend\\Di\\Display\\Console::export($di, ['A\\ClassIWantTo\\GetTheDefinitionFor']);",
            "title": "Debugging a DiC"
        },
        {
            "location": "/v2/debugging-and-complex-use-cases/#complex-use-cases",
            "text": "",
            "title": "Complex Use Cases"
        },
        {
            "location": "/v2/debugging-and-complex-use-cases/#interface-injection",
            "text": "namespace Foo\\Bar\n{\n    class Baz implements BamAwareInterface\n    {\n        public $bam;\n\n        public function setBam(Bam $bam)\n        {\n            $this->bam = $bam;\n        }\n    }\n\n    class Bam\n    {\n    }\n\n    interface BamAwareInterface\n    {\n        public function setBam(Bam $bam);\n    }\n}\n\nnamespace {\n    include 'zf2bootstrap.php';\n    $di = new Zend\\Di\\Di;\n    $baz = $di->get('Foo\\Bar\\Baz');\n}",
            "title": "Interface Injection"
        },
        {
            "location": "/v2/debugging-and-complex-use-cases/#setter-injection-with-class-definition",
            "text": "namespace Foo\\Bar\n{\n    class Baz\n    {\n        public $bam;\n\n        public function setBam(Bam $bam)\n        {\n            $this->bam = $bam;\n        }\n    }\n\n    class Bam {\n    }\n}\n\nnamespace {\n    $di = new Zend\\Di\\Di;\n    $di->configure(new Zend\\Di\\Config([\n        'definition' => [\n            'class' => [\n                'Foo\\Bar\\Baz' => [\n                    'setBam' => ['required' => true],\n                ],\n            ],\n        ],\n    ]));\n    $baz = $di->get('Foo\\Bar\\Baz');\n}",
            "title": "Setter Injection with Class Definition"
        },
        {
            "location": "/v2/debugging-and-complex-use-cases/#multiple-injections-to-a-single-injection-point",
            "text": "namespace Application\n{\n    class Page\n    {\n        public $blocks;\n\n        public function addBlock(Block $block)\n        {\n            $this->blocks[] = $block;\n        }\n    }\n\n    interface Block\n    {\n    }\n}\n\nnamespace MyModule {\n    class BlockOne implements \\Application\\Block {}\n    class BlockTwo implements \\Application\\Block {}\n}\n\nnamespace {\n    include 'zf2bootstrap.php';\n    $di = new Zend\\Di\\Di;\n    $di->configure(new Zend\\Di\\Config([\n        'definition' => [\n            'class' => [\n                'Application\\Page' => [\n                    'addBlock' => [\n                        'block' => [\n                            'type' => 'Application\\Block',\n                            'required' => true,\n                        ],\n                    ],\n                ],\n            ],\n        ],\n        'instance' => [\n            'Application\\Page' => [\n                'injections' => [\n                    'MyModule\\BlockOne',\n                    'MyModule\\BlockTwo',\n                ],\n            ],\n        ],\n    ]));\n    $page = $di->get('Application\\Page');\n}",
            "title": "Multiple Injections To A Single Injection Point"
        },
        {
            "location": "/cookbook/use-with-psr-containers/",
            "text": "Usage with PSR-11 containers\n\n\nzend-di is designed to utilize and work with any IoC container thet implements\nthe PSR-11 \nPsr\\Container\\ContainerInterface\n. To achieve this you can pass any\ncontainer instance as the second parameter to the injector:\n\n\nuse Zend\\Di\\Injector;\n\n$injector = new Injector(null, $container);\n\n\n\nFrom that point forwards, the injector will use the provided \n$container\n to\nobtain the dependencies.\n\n\nDecorating the container\n\n\nIn the example above, the provided container may not utilize the injector to\ncreate unknown instances, even when the classes are known to zend-di. It may\nfail with an exception that dependencies could not be resolved.\n\n\nIf you want to pair the container with the injector and use the injector for\ndependencies the container it is not aware of, you may decorate the original\ncontainer into a zend-di-aware implementation. As an example:\n\n\nnamespace MyApp;\n\nuse Zend\\Di\\Injector;\nuse Psr\\Container\\ContainerInterface;\n\nclass MyContainer implements ContainerInterface\n{\n    private $container;\n\n    private $injector;\n\n    public function __construct(ContainerInterface $container)\n    {\n        $this->container = $wrappedContainer;\n        $this->injector = new Injector(null, $this);\n    }\n\n    public function has($name)\n    {\n        retrun $this->container->has($name) || $this->injector->canCreate($name);\n    }\n\n    public function get($name)\n    {\n        if ($this->container->has($name)) {\n            return $this->container->get($name);\n        }\n\n        $service = $this->injector->create($name);\n\n        // You might make the service shared via the decorated container\n        // as well:\n        // $this->container->set($name, $service);\n\n        return $service;\n    }\n}",
            "title": "Usage with PSR-11 Containers"
        },
        {
            "location": "/cookbook/use-with-psr-containers/#usage-with-psr-11-containers",
            "text": "zend-di is designed to utilize and work with any IoC container thet implements\nthe PSR-11  Psr\\Container\\ContainerInterface . To achieve this you can pass any\ncontainer instance as the second parameter to the injector:  use Zend\\Di\\Injector;\n\n$injector = new Injector(null, $container);  From that point forwards, the injector will use the provided  $container  to\nobtain the dependencies.",
            "title": "Usage with PSR-11 containers"
        },
        {
            "location": "/cookbook/use-with-psr-containers/#decorating-the-container",
            "text": "In the example above, the provided container may not utilize the injector to\ncreate unknown instances, even when the classes are known to zend-di. It may\nfail with an exception that dependencies could not be resolved.  If you want to pair the container with the injector and use the injector for\ndependencies the container it is not aware of, you may decorate the original\ncontainer into a zend-di-aware implementation. As an example:  namespace MyApp;\n\nuse Zend\\Di\\Injector;\nuse Psr\\Container\\ContainerInterface;\n\nclass MyContainer implements ContainerInterface\n{\n    private $container;\n\n    private $injector;\n\n    public function __construct(ContainerInterface $container)\n    {\n        $this->container = $wrappedContainer;\n        $this->injector = new Injector(null, $this);\n    }\n\n    public function has($name)\n    {\n        retrun $this->container->has($name) || $this->injector->canCreate($name);\n    }\n\n    public function get($name)\n    {\n        if ($this->container->has($name)) {\n            return $this->container->get($name);\n        }\n\n        $service = $this->injector->create($name);\n\n        // You might make the service shared via the decorated container\n        // as well:\n        // $this->container->set($name, $service);\n\n        return $service;\n    }\n}",
            "title": "Decorating the container"
        },
        {
            "location": "/cookbook/use-with-servicemanager/",
            "text": "Usage With zend-servicemanager\n\n\nzend-di is designed to play and integrate well with zend-servicemanager.  When\nyou are using \nzend-component-installer\n,\nyou just need to install zend-di via composer and you're done.\n\n\nService Factories For DI instances\n\n\nzend-di ships with two service factories to provide the\n\nZend\\Di\\InjectorInterface\n implementation.\n\n\n\n\n\n\nZend\\Di\\Container\\ConfigFactory\n: Creates a config instance by using the \n\"config\"\n service.\n\n\n\n\n\n\nZend\\Di\\Container\\InjectorFactory\n: Creates the injector instance that uses a\n  \nZend\\Di\\ConfigInterface\n service, if available.\n\n\n\n\n\n\nuse Zend\\Di;\nuse Zend\\Di\\Container;\n\n$serviceManager->setFactory(Di\\ConfigInterface::class, Container\\ConfigFactory::class);\n$serviceManager->setFactory(Di\\InjectorInterface::class, Container\\InjectorFactory::class);\n\n\n\nAbstract/Generic Service Factory\n\n\nThis component ships with an generic factory\n\nZend\\Di\\Container\\AutowireFactory\n. This factory is suitable as an abstract\nservice factory for use with zend-servicemanager.\n\n\nYou can also use it to create instances with zend-di using an IoC container\n(e.g. inside a service factory):\n\n\nuse Zend\\Di\\Container\\AutowireFactory;\n(new AutowireFactory())->__invoke($container, MyClassname::class);\n\n\n\nOr you can use it as factory in your service configuration directly:\n\n\nreturn [\n    'factories' => [\n        SomeClass::class => \\Zend\\Di\\Container\\AutowireFactory::class,\n    ],\n];\n\n\n\nService Factory For AoT Code Generation\n\n\nzend-di also provides a factory for \nZend\\Di\\CodeGenerator\\InjectorGenerator\n.\nThis factory (\nZend\\Di\\Container\\GeneratorFactory\n) is also auto registered by\nthe \nModule\n and \nConfigProvider\n classes for zend-mvc and Expressive.",
            "title": "Usage with zend-servicemanager"
        },
        {
            "location": "/cookbook/use-with-servicemanager/#usage-with-zend-servicemanager",
            "text": "zend-di is designed to play and integrate well with zend-servicemanager.  When\nyou are using  zend-component-installer ,\nyou just need to install zend-di via composer and you're done.",
            "title": "Usage With zend-servicemanager"
        },
        {
            "location": "/cookbook/use-with-servicemanager/#service-factories-for-di-instances",
            "text": "zend-di ships with two service factories to provide the Zend\\Di\\InjectorInterface  implementation.    Zend\\Di\\Container\\ConfigFactory : Creates a config instance by using the  \"config\"  service.    Zend\\Di\\Container\\InjectorFactory : Creates the injector instance that uses a\n   Zend\\Di\\ConfigInterface  service, if available.    use Zend\\Di;\nuse Zend\\Di\\Container;\n\n$serviceManager->setFactory(Di\\ConfigInterface::class, Container\\ConfigFactory::class);\n$serviceManager->setFactory(Di\\InjectorInterface::class, Container\\InjectorFactory::class);",
            "title": "Service Factories For DI instances"
        },
        {
            "location": "/cookbook/use-with-servicemanager/#abstractgeneric-service-factory",
            "text": "This component ships with an generic factory Zend\\Di\\Container\\AutowireFactory . This factory is suitable as an abstract\nservice factory for use with zend-servicemanager.  You can also use it to create instances with zend-di using an IoC container\n(e.g. inside a service factory):  use Zend\\Di\\Container\\AutowireFactory;\n(new AutowireFactory())->__invoke($container, MyClassname::class);  Or you can use it as factory in your service configuration directly:  return [\n    'factories' => [\n        SomeClass::class => \\Zend\\Di\\Container\\AutowireFactory::class,\n    ],\n];",
            "title": "Abstract/Generic Service Factory"
        },
        {
            "location": "/cookbook/use-with-servicemanager/#service-factory-for-aot-code-generation",
            "text": "zend-di also provides a factory for  Zend\\Di\\CodeGenerator\\InjectorGenerator .\nThis factory ( Zend\\Di\\Container\\GeneratorFactory ) is also auto registered by\nthe  Module  and  ConfigProvider  classes for zend-mvc and Expressive.",
            "title": "Service Factory For AoT Code Generation"
        },
        {
            "location": "/cookbook/aot-guide/",
            "text": "Using AoT with Expressive and zend-servicemanager\n\n\nThis guide will show you how you can use zend-di's Ahead-of-Time (AoT) compiler\nto make your \nExpressive\n\napplication production ready when it uses zend-di.\n\n\nYou will learn how to:\n\n\n\n\nAdd a script to run the compilation.\n\n\nUse the generated injector with zend-servicemanager.\n\n\nUse the generated factories with zend-servicemanager.\n\n\n\n\n1. Create project and add zend-di\n\n\nFor this guide, we will use an \nexpressive application\n\nbuilt from the skeleton with zend-servicemanager as its IoC container.\n\n\nIf you have already set up a project with zend-di, you can skip this step.\n\n\nFirst, we'll create a new project:\n\n\n$ composer create-project zendframework/zend-expressive-skeleton zend-di-aot-example\n\n\n\nPick the components you want to use. We will be using zend-servicemanager\nand a \"Modular\" layout for this example.\n\n\nOnce you are done, enter the newly created project's working directory:\n\n\n$ cd zend-di-aot-example\n\n\n\nNow add zend-di with composer:\n\n\n$ composer require zendframework/zend-di\n\n\n\n\n\nPossible version conflicts\n\n\nPlease make sure that zend-di version 3.x is installed. When you are\nupgrading from zend-di version 2.x, you may have to remove\n\nzend-servicemanager-di\n because version 3.x makes this package obsolete and\ntherefore conflicts with it.\n\n\nYou can ensure version 3.x is installed by adding a version constraint to\ncomposer's require command:\n\n\n$ composer require zendframework/zend-di:^3.0\n\n\n\nThis approach will also notify you if there are conflicts with installing v3. \n\n\nAdditional requirements for version 3.0.x\n\n\nBefore version 3.1, \nzendframework/zend-code\n was required to be\nadded individually to your project for generating AoT code. Since version \n3.1 this is no longer necessary.\n\n\n\n\nThe component installer should ask you where to inject the config provider. Pick\noption 1, which usually is \nconfig/config.php\n. If not, or you cannot use the\ncomponent installer, you will need to add it manually by adding an entry for\n\n\\Zend\\Di\\ConfigProvider::class\n within your application configuration\nexample):\n\n\n<?php\n// config/config.php:\n\nuse Zend\\ConfigAggregator\\ArrayProvider;\nuse Zend\\ConfigAggregator\\ConfigAggregator;\nuse Zend\\ConfigAggregator\\PhpFileProvider;\n\n// ...\n\n$aggregator = new ConfigAggregator([\n    // Add Zend\\Di\n    \\Zend\\Di\\ConfigProvider::class,\n\n    // ...\n], $cacheConfig['config_cache_path']);\n\n// ...\n\n\n\n2. Make your project ready for AoT\n\n\nTo follow the modular principle of our expressive app, we will put the AoT\nrelated configurations and generated code in a separate module called \nAppAoT\n.\n\n\nBy default, skeleton applications include the zend-expressive-tooling component,\nwhich allows you to do this in a single step:\n\n\n$ ./vendor/bin/expressive module:create AppAoT\n\n\n\nIf the tooling is present and the above command is successful, you can now skip\nto the next step. Otherwise, continue on to manually create your module.\n\n\nFirst, create the initial directory structure:\n\n\n$ mkdir src/AppAoT/src\n\n\n\nNext, create a config provider class in \nsrc/AppAoT/src/ConfigProvider.php\n:\n\n\n<?php\n\nnamespace AppAoT;\n\nclass ConfigProvider\n{\n    public function __invoke()\n    {\n        return [\n            'dependencies' => $this->getDependencies(),\n        ];\n    }\n\n    public function getDependencies()\n    {\n        return [\n            'auto' => [\n                'aot' => [\n                    'namespace' => __NAMESPACE__ . '\\\\Generated',\n                    'directory' => __DIR__ . '/../gen',\n                ],\n            ],\n        ];\n    }\n}\n\n\n\nAdd this new class to the the beginning of your \nconfig/config.php\n file's\n\nConfigAggregator\n settings:\n\n\n$aggregator = new ConfigAggregator([\n    \\AppAoT\\ConfigProvider::class\n    // Add Zend\\Di\n    \\Zend\\Di\\ConfigProvider::class,\n\n    // ...\n]);\n\n\n\nIn order for your application to find this class, we need to add an autoloading\nrule. Find the \npsr-4\n autoloader section of your \ncomposer.json\n, and add an\nentry for your new \nAppAot\n namespace as follows:\n\n\n{\n    \"autoload\": {\n        \"psr-4\": {\n            \"App\\\\\": \"src/App/src/\",\n            \"AppAoT\\\\\": \"src/AppAoT/src/\",\n            \"AppAoT\\\\Generated\\\\\": \"src/AppAoT/gen/\"\n        }\n    },\n    ...\n}\n\n\n\n\n\nNote that we defined \nAppAoT\\\\Generated\\\\\n which will point to the code\nwe generate from zend-di in the next steps.\n\n\n\n\nFinally, update your autoloader:\n\n\n$ composer dump-autoload\n\n\n\n3. Add some auto-wiring\n\n\nBecause zend-di can provide autowiring for us, we can remove configuration that\nalready exists within our \nApp\n module. Edit the file\n\nsrc/App/src/ConfigProvider.php\n and comment out the entries shown below:\n\n\n    public function getDependencies()\n    {\n        return [\n            'invokables' => [\n                // Action\\PingAction::class => Action\\PingAction::class,\n            ],\n            'factories'  => [\n                // Action\\HomePageAction::class => Action\\HomePageFactory::class,\n            ],\n        ];\n    }\n\n\n\nWe can also now remove the \nHomePageFactory\n referenced in that method:\n\n\n$ rm src/App/src/HomePageFactory.php\n\n\n\nThe default actions (\nHomePageAction\n and \nPingAction\n) now use auto wiring!\n\n\n4. Add a code generator command script\n\n\nWe will now add a simple script in the \nbin/\n directory, which we will also add\nto our \ncomposer.json\nscripts section, to generate factories.\n\n\nIn the real world, you might use a console implementation such as\nsymfony/console for scripts such as these.\n\n\nAdd the generator script \nbin/di-generate-aot.php\n:\n\n\n<?php\n\nnamespace AppAoT;\n\nuse Psr\\Container\\ContainerInterface;\nuse Zend\\Code\\Scanner\\DirectoryScanner;\nuse Zend\\Di\\CodeGenerator\\InjectorGenerator;\nuse Zend\\Di\\Config;\n\nrequire __DIR__ . '/../vendor/autoload.php';\n\n// Define the source directories to scan for classes for which\n// to generate AoT factories:\n$directories = [\n    __DIR__ . '/../src/App/src',\n];\n\n/** @var ContainerInterface $container */\n$container = require __DIR__ . '/../config/container.php';\n$scanner = new DirectoryScanner($directories);\n$generator = $container->get(InjectorGenerator::class);\n\n$generator->generate($scanner->getClassNames());\n\n\n\n\n\nManually creating a generator instance\n\n\nBefore version 3.1, no service factory existed for the generator. Below is an\nexample demonstrating manual creation of the generator:\n\n\n<?php\n\nnamespace AppAoT;\n\nuse Psr\\Container\\ContainerInterface;\nuse Zend\\Code\\Scanner\\DirectoryScanner;\nuse Zend\\Di\\CodeGenerator\\InjectorGenerator;\nuse Zend\\Di\\Config;\nuse Zend\\Di\\ConfigInterface;\nuse Zend\\Di\\Definition\\RuntimeDefinition;\nuse Zend\\Di\\Resolver\\DependencyResolver;\n\nrequire __DIR__ . '/../vendor/autoload.php';\n\n$directories = [\n    __DIR__ . '/../src/App/src',\n];\n\n// Generator dependencies. You might put this in a service factory\n// in a real-life scenario.\n\n/** @var ContainerInterface $container */\n$container = require __DIR__ . '/../config/container.php';\n$config = $container->get(ConfigInterface::class);\n$resolver = new DependencyResolver(new RuntimeDefinition(), $config);\n\n// This is important; we want to use configured aliases of the service manager.\n$resolver->setContainer($container);\n\n$scanner = new DirectoryScanner($directories);\n$generator = new InjectorGenerator($config, $resolver, __NAMESPACE__ . '\\Generated');\n$generator->setOutputDirectory(__DIR__ . '/../src/AppAoT/gen');\n$generator->generate($scanner->getClassNames());\n\n\n\n\n\nTo add the Composer script, edit \ncomposer.json\n and add the following to the\n\nscripts\n section:\n\n\n{\n    \"scripts\": {\n        \"di-generate-aot\": [\n            \"rm -vfr src/AppAoT/gen\",\n            \"php bin/di-generate-aot.php\"\n        ]\n    }\n}\n\n\n\nWhen running the compiler with \ncomposer di-generate-aot\n, it will generate\nthe following files:\n\n\n\n\n5. Add AoT to the service manager\n\n\nNow we need to make the service manager use the AoT code.\n\n\nFirst, we'll create a delegate factory to decorate the DI injector with the AoT\nversion. Decorating the injector ensures that your factories that utilize\n\nZend\\Di\\Container\\AutowireFactory\n will benefit from AoT as well.\n\n\nCreate the file \nsrc/AppAoT/src/InjectorDecoratorFactory.php\n with the following\ncontents:\n\n\n<?php\n\nnamespace AppAoT;\n\nuse AppAoT\\Generated\\GeneratedInjector;\nuse Interop\\Container\\ContainerInterface;\nuse Zend\\ServiceManager\\Factory\\DelegatorFactoryInterface;\n\nclass InjectorDecoratorFactory implements DelegatorFactoryInterface\n{\n    public function __invoke(ContainerInterface $container, $name, callable $callback, array $options = null)\n    {\n        $injector = $callback();\n\n        if (class_exists(GeneratedInjector::class)) {\n            return new GeneratedInjector($injector);\n        }\n\n        return $injector;\n    }\n}\n\n\n\nAfter this we need to add configuration to the \nConfigProvider\n class we created\nin step 2:\n\n\n\n\nImportant:\n After this step, the application will \nalways\n use the\ngenerated factories, if present. If you change any dependencies, you will need\nto run \ncomposer di-aot-generation\n again, or remove the generated code in\n\nsrc/AppAoT/gen/\n and use runtime wiring.\n\n\n\n\n<?php\n\nnamespace AppAoT;\n\nuse Zend\\Di\\InjectorInterface;\n\nclass ConfigProvider\n{\n    public function __invoke()\n    {\n        return [\n            'dependencies' => $this->getDependencies(),\n        ];\n    }\n\n    public function getDependencies()\n    {\n        return [\n            'auto' => [\n                'aot' => [\n                    'namespace' => __NAMESPACE__ . '\\\\Generated',\n                    'directory' => __DIR__ . '/../gen',\n                ],\n            ],\n            'factories' => $this->getGeneratedFactories(),\n            'delegators' => [\n                InjectorInterface::class => [\n                    InjectorDecoratorFactory::class,\n                ],\n            ],\n        ];\n    }\n\n    private function getGeneratedFactories()\n    {\n        // The generated factories.php file is compatible with\n        // zend-servicemanager's factory configuration.\n        // This avoids using the abstract AutowireFactory, which\n        // improves performance a bit since we spare some lookups.\n\n        if (file_exists(__DIR__ . '/../gen/factories.php')) {\n            return include __DIR__ . '/../gen/factories.php';\n        }\n\n        return [];\n    }\n}",
            "title": "Using AoT with Expressive and zend-servicemanager"
        },
        {
            "location": "/cookbook/aot-guide/#using-aot-with-expressive-and-zend-servicemanager",
            "text": "This guide will show you how you can use zend-di's Ahead-of-Time (AoT) compiler\nto make your  Expressive \napplication production ready when it uses zend-di.  You will learn how to:   Add a script to run the compilation.  Use the generated injector with zend-servicemanager.  Use the generated factories with zend-servicemanager.",
            "title": "Using AoT with Expressive and zend-servicemanager"
        },
        {
            "location": "/cookbook/aot-guide/#1-create-project-and-add-zend-di",
            "text": "For this guide, we will use an  expressive application \nbuilt from the skeleton with zend-servicemanager as its IoC container.  If you have already set up a project with zend-di, you can skip this step.  First, we'll create a new project:  $ composer create-project zendframework/zend-expressive-skeleton zend-di-aot-example  Pick the components you want to use. We will be using zend-servicemanager\nand a \"Modular\" layout for this example.  Once you are done, enter the newly created project's working directory:  $ cd zend-di-aot-example  Now add zend-di with composer:  $ composer require zendframework/zend-di",
            "title": "1. Create project and add zend-di"
        },
        {
            "location": "/cookbook/aot-guide/#possible-version-conflicts",
            "text": "Please make sure that zend-di version 3.x is installed. When you are\nupgrading from zend-di version 2.x, you may have to remove zend-servicemanager-di  because version 3.x makes this package obsolete and\ntherefore conflicts with it.  You can ensure version 3.x is installed by adding a version constraint to\ncomposer's require command:  $ composer require zendframework/zend-di:^3.0  This approach will also notify you if there are conflicts with installing v3.",
            "title": "Possible version conflicts"
        },
        {
            "location": "/cookbook/aot-guide/#additional-requirements-for-version-30x",
            "text": "Before version 3.1,  zendframework/zend-code  was required to be\nadded individually to your project for generating AoT code. Since version \n3.1 this is no longer necessary.   The component installer should ask you where to inject the config provider. Pick\noption 1, which usually is  config/config.php . If not, or you cannot use the\ncomponent installer, you will need to add it manually by adding an entry for \\Zend\\Di\\ConfigProvider::class  within your application configuration\nexample):  <?php\n// config/config.php:\n\nuse Zend\\ConfigAggregator\\ArrayProvider;\nuse Zend\\ConfigAggregator\\ConfigAggregator;\nuse Zend\\ConfigAggregator\\PhpFileProvider;\n\n// ...\n\n$aggregator = new ConfigAggregator([\n    // Add Zend\\Di\n    \\Zend\\Di\\ConfigProvider::class,\n\n    // ...\n], $cacheConfig['config_cache_path']);\n\n// ...",
            "title": "Additional requirements for version 3.0.x"
        },
        {
            "location": "/cookbook/aot-guide/#2-make-your-project-ready-for-aot",
            "text": "To follow the modular principle of our expressive app, we will put the AoT\nrelated configurations and generated code in a separate module called  AppAoT .  By default, skeleton applications include the zend-expressive-tooling component,\nwhich allows you to do this in a single step:  $ ./vendor/bin/expressive module:create AppAoT  If the tooling is present and the above command is successful, you can now skip\nto the next step. Otherwise, continue on to manually create your module.  First, create the initial directory structure:  $ mkdir src/AppAoT/src  Next, create a config provider class in  src/AppAoT/src/ConfigProvider.php :  <?php\n\nnamespace AppAoT;\n\nclass ConfigProvider\n{\n    public function __invoke()\n    {\n        return [\n            'dependencies' => $this->getDependencies(),\n        ];\n    }\n\n    public function getDependencies()\n    {\n        return [\n            'auto' => [\n                'aot' => [\n                    'namespace' => __NAMESPACE__ . '\\\\Generated',\n                    'directory' => __DIR__ . '/../gen',\n                ],\n            ],\n        ];\n    }\n}  Add this new class to the the beginning of your  config/config.php  file's ConfigAggregator  settings:  $aggregator = new ConfigAggregator([\n    \\AppAoT\\ConfigProvider::class\n    // Add Zend\\Di\n    \\Zend\\Di\\ConfigProvider::class,\n\n    // ...\n]);  In order for your application to find this class, we need to add an autoloading\nrule. Find the  psr-4  autoloader section of your  composer.json , and add an\nentry for your new  AppAot  namespace as follows:  {\n    \"autoload\": {\n        \"psr-4\": {\n            \"App\\\\\": \"src/App/src/\",\n            \"AppAoT\\\\\": \"src/AppAoT/src/\",\n            \"AppAoT\\\\Generated\\\\\": \"src/AppAoT/gen/\"\n        }\n    },\n    ...\n}   Note that we defined  AppAoT\\\\Generated\\\\  which will point to the code\nwe generate from zend-di in the next steps.   Finally, update your autoloader:  $ composer dump-autoload",
            "title": "2. Make your project ready for AoT"
        },
        {
            "location": "/cookbook/aot-guide/#3-add-some-auto-wiring",
            "text": "Because zend-di can provide autowiring for us, we can remove configuration that\nalready exists within our  App  module. Edit the file src/App/src/ConfigProvider.php  and comment out the entries shown below:      public function getDependencies()\n    {\n        return [\n            'invokables' => [\n                // Action\\PingAction::class => Action\\PingAction::class,\n            ],\n            'factories'  => [\n                // Action\\HomePageAction::class => Action\\HomePageFactory::class,\n            ],\n        ];\n    }  We can also now remove the  HomePageFactory  referenced in that method:  $ rm src/App/src/HomePageFactory.php  The default actions ( HomePageAction  and  PingAction ) now use auto wiring!",
            "title": "3. Add some auto-wiring"
        },
        {
            "location": "/cookbook/aot-guide/#4-add-a-code-generator-command-script",
            "text": "We will now add a simple script in the  bin/  directory, which we will also add\nto our  composer.json scripts section, to generate factories.  In the real world, you might use a console implementation such as\nsymfony/console for scripts such as these.  Add the generator script  bin/di-generate-aot.php :  <?php\n\nnamespace AppAoT;\n\nuse Psr\\Container\\ContainerInterface;\nuse Zend\\Code\\Scanner\\DirectoryScanner;\nuse Zend\\Di\\CodeGenerator\\InjectorGenerator;\nuse Zend\\Di\\Config;\n\nrequire __DIR__ . '/../vendor/autoload.php';\n\n// Define the source directories to scan for classes for which\n// to generate AoT factories:\n$directories = [\n    __DIR__ . '/../src/App/src',\n];\n\n/** @var ContainerInterface $container */\n$container = require __DIR__ . '/../config/container.php';\n$scanner = new DirectoryScanner($directories);\n$generator = $container->get(InjectorGenerator::class);\n\n$generator->generate($scanner->getClassNames());",
            "title": "4. Add a code generator command script"
        },
        {
            "location": "/cookbook/aot-guide/#manually-creating-a-generator-instance",
            "text": "Before version 3.1, no service factory existed for the generator. Below is an\nexample demonstrating manual creation of the generator:  <?php\n\nnamespace AppAoT;\n\nuse Psr\\Container\\ContainerInterface;\nuse Zend\\Code\\Scanner\\DirectoryScanner;\nuse Zend\\Di\\CodeGenerator\\InjectorGenerator;\nuse Zend\\Di\\Config;\nuse Zend\\Di\\ConfigInterface;\nuse Zend\\Di\\Definition\\RuntimeDefinition;\nuse Zend\\Di\\Resolver\\DependencyResolver;\n\nrequire __DIR__ . '/../vendor/autoload.php';\n\n$directories = [\n    __DIR__ . '/../src/App/src',\n];\n\n// Generator dependencies. You might put this in a service factory\n// in a real-life scenario.\n\n/** @var ContainerInterface $container */\n$container = require __DIR__ . '/../config/container.php';\n$config = $container->get(ConfigInterface::class);\n$resolver = new DependencyResolver(new RuntimeDefinition(), $config);\n\n// This is important; we want to use configured aliases of the service manager.\n$resolver->setContainer($container);\n\n$scanner = new DirectoryScanner($directories);\n$generator = new InjectorGenerator($config, $resolver, __NAMESPACE__ . '\\Generated');\n$generator->setOutputDirectory(__DIR__ . '/../src/AppAoT/gen');\n$generator->generate($scanner->getClassNames());   To add the Composer script, edit  composer.json  and add the following to the scripts  section:  {\n    \"scripts\": {\n        \"di-generate-aot\": [\n            \"rm -vfr src/AppAoT/gen\",\n            \"php bin/di-generate-aot.php\"\n        ]\n    }\n}  When running the compiler with  composer di-generate-aot , it will generate\nthe following files:",
            "title": "Manually creating a generator instance"
        },
        {
            "location": "/cookbook/aot-guide/#5-add-aot-to-the-service-manager",
            "text": "Now we need to make the service manager use the AoT code.  First, we'll create a delegate factory to decorate the DI injector with the AoT\nversion. Decorating the injector ensures that your factories that utilize Zend\\Di\\Container\\AutowireFactory  will benefit from AoT as well.  Create the file  src/AppAoT/src/InjectorDecoratorFactory.php  with the following\ncontents:  <?php\n\nnamespace AppAoT;\n\nuse AppAoT\\Generated\\GeneratedInjector;\nuse Interop\\Container\\ContainerInterface;\nuse Zend\\ServiceManager\\Factory\\DelegatorFactoryInterface;\n\nclass InjectorDecoratorFactory implements DelegatorFactoryInterface\n{\n    public function __invoke(ContainerInterface $container, $name, callable $callback, array $options = null)\n    {\n        $injector = $callback();\n\n        if (class_exists(GeneratedInjector::class)) {\n            return new GeneratedInjector($injector);\n        }\n\n        return $injector;\n    }\n}  After this we need to add configuration to the  ConfigProvider  class we created\nin step 2:   Important:  After this step, the application will  always  use the\ngenerated factories, if present. If you change any dependencies, you will need\nto run  composer di-aot-generation  again, or remove the generated code in src/AppAoT/gen/  and use runtime wiring.   <?php\n\nnamespace AppAoT;\n\nuse Zend\\Di\\InjectorInterface;\n\nclass ConfigProvider\n{\n    public function __invoke()\n    {\n        return [\n            'dependencies' => $this->getDependencies(),\n        ];\n    }\n\n    public function getDependencies()\n    {\n        return [\n            'auto' => [\n                'aot' => [\n                    'namespace' => __NAMESPACE__ . '\\\\Generated',\n                    'directory' => __DIR__ . '/../gen',\n                ],\n            ],\n            'factories' => $this->getGeneratedFactories(),\n            'delegators' => [\n                InjectorInterface::class => [\n                    InjectorDecoratorFactory::class,\n                ],\n            ],\n        ];\n    }\n\n    private function getGeneratedFactories()\n    {\n        // The generated factories.php file is compatible with\n        // zend-servicemanager's factory configuration.\n        // This avoids using the abstract AutowireFactory, which\n        // improves performance a bit since we spare some lookups.\n\n        if (file_exists(__DIR__ . '/../gen/factories.php')) {\n            return include __DIR__ . '/../gen/factories.php';\n        }\n\n        return [];\n    }\n}",
            "title": "5. Add AoT to the service manager"
        },
        {
            "location": "/migration/",
            "text": "Migration Guide\n\n\nVersion 3 is the first new major release of zend-di, and contains a number of\nbackward incompatible changes. These were introduced to provide better\nperformance, stability, and predictability.\n\n\nThis guide describes how to migrate from Version 2 to 3.\n\n\nWhat has changed?\n\n\nThis lists the most impacting changes and potential pitfalls when\nupgrading to \nzend-di\n version 3.\n\n\n\n\n\n\nThe injector now only supports constructor injections. If you require\n  injections based on \"Aware\" interfaces or setter/method injections, you need\n  to provide these on your own. You could do this by decorating the injector\n  instance or using initializers in zend-servicemanager.\n\n\n\n\n\n\n\\Zend\\Di\\Di\n is renamed to \n\\Zend\\Di\\InjectorInterface\n. It also is no longer\n  an IoC container which offers \nget()\n/\nhas()\n. Container functionality is now\n  provided via \nZend\\Di\\DefaultContainer\n, which implements\n  \nPsr\\Container\\ContainerInterface\n.  If you were using \n\\Zend\\Di\\Di\n as an IoC\n  container, please switch to \nZend\\Di\\DefaultContainer\n or use it with\n  \nzend-servicemanager\n.\n\n\n\n\n\n\nAll programmatic and array-based definitions were dropped. If you need custom\n  definitions, implement \n\\Zend\\Di\\Definition\\DefinitionInterface\n.\n\n\n\n\n\n\nThe definition compiler was removed in favor of a \ncode generator\n,\n  which offers better performance.\n\n\n\n\n\n\nAdded PHP 7.1 type safety. All interfaces and classes are strongly typed, and\n  all methods use return typehints, as well as scalar typehints where needed.\n\n\n\n\n\n\nGenerator\n and \nGeneratorInstance\n in \nZend\\Di\\ServiceLocator\n were removed\n  in favor of the \ncode generator\n, which creates zend-servicemanager\n  compatible factories.\n\n\n\n\n\n\nMigrating from v2 to v3 with zend-mvc\n\n\nWhen you are using zend-mvc, you can follow these steps to upgrade:\n\n\n\n\nRemove \nzendframework/zend-servicemanager-di\nfrom your \ncomposer.json\n, or\n   execute \ncomposer remove zendframework/zend-servicemanager-di\n.\n\n\nChange the version constraint for \nzendframework/zend-di\n to \n^3.0\n, or\n   execute \ncomposer require \"zendframework/zend-di:^3.0\"\n.\n\n\nChange any remaining module entries for \nZend\\ServiceManager\\Di\\Module\n to\n   \nZend\\Di\\Module\n within either \nconfig/application.config.php\n or\n   \nconfig/modules.config.php\n.\n\n\nIf you are using any factories from zend-servicemanager-di, you may have to\n   replace them with \nZend\\Di\\Container\\AutowireFactory\n.\n\n\nMigrate your zend-di config to the new \nconfiguration format\n.\n\n\n\n\nMigrating configuration\n\n\nzend-di configuration is now expected in \n$config['dependencies']['auto']\n,\nwhere \n$config\n is your \nconfig\n service.\n\n\nThe zend-di config service factory will automatically attempt to migrate legacy\nconfigurations at runtime, which gives you some time to migrate your configs.\nYou can use \nZend\\Di\\LegacyConfig\n to help migrating existing configs:\n\n\nuse Zend\\Di\\LegacyConfig;\n\n$migrated = new LegacyConfig($diConfigArray);\n$code = var_export($migrated->toArray(), true);\n\n\n\nWhen the zend-di config service factory is used to create configuration for use\nwith the \nAutowireFactory\n and/or \nDefaultContainer\n, if it detects the\n\n$config['di]\n key, it will emit an \nE_USER_DEPRECATED\n error, pointing to this\ndocumentation. We recommend using the above approach to convert your\nconfiguration to the format recognized by version 3.",
            "title": "Migration Guide"
        },
        {
            "location": "/migration/#migration-guide",
            "text": "Version 3 is the first new major release of zend-di, and contains a number of\nbackward incompatible changes. These were introduced to provide better\nperformance, stability, and predictability.  This guide describes how to migrate from Version 2 to 3.",
            "title": "Migration Guide"
        },
        {
            "location": "/migration/#what-has-changed",
            "text": "This lists the most impacting changes and potential pitfalls when\nupgrading to  zend-di  version 3.    The injector now only supports constructor injections. If you require\n  injections based on \"Aware\" interfaces or setter/method injections, you need\n  to provide these on your own. You could do this by decorating the injector\n  instance or using initializers in zend-servicemanager.    \\Zend\\Di\\Di  is renamed to  \\Zend\\Di\\InjectorInterface . It also is no longer\n  an IoC container which offers  get() / has() . Container functionality is now\n  provided via  Zend\\Di\\DefaultContainer , which implements\n   Psr\\Container\\ContainerInterface .  If you were using  \\Zend\\Di\\Di  as an IoC\n  container, please switch to  Zend\\Di\\DefaultContainer  or use it with\n   zend-servicemanager .    All programmatic and array-based definitions were dropped. If you need custom\n  definitions, implement  \\Zend\\Di\\Definition\\DefinitionInterface .    The definition compiler was removed in favor of a  code generator ,\n  which offers better performance.    Added PHP 7.1 type safety. All interfaces and classes are strongly typed, and\n  all methods use return typehints, as well as scalar typehints where needed.    Generator  and  GeneratorInstance  in  Zend\\Di\\ServiceLocator  were removed\n  in favor of the  code generator , which creates zend-servicemanager\n  compatible factories.",
            "title": "What has changed?"
        },
        {
            "location": "/migration/#migrating-from-v2-to-v3-with-zend-mvc",
            "text": "When you are using zend-mvc, you can follow these steps to upgrade:   Remove  zendframework/zend-servicemanager-di from your  composer.json , or\n   execute  composer remove zendframework/zend-servicemanager-di .  Change the version constraint for  zendframework/zend-di  to  ^3.0 , or\n   execute  composer require \"zendframework/zend-di:^3.0\" .  Change any remaining module entries for  Zend\\ServiceManager\\Di\\Module  to\n    Zend\\Di\\Module  within either  config/application.config.php  or\n    config/modules.config.php .  If you are using any factories from zend-servicemanager-di, you may have to\n   replace them with  Zend\\Di\\Container\\AutowireFactory .  Migrate your zend-di config to the new  configuration format .",
            "title": "Migrating from v2 to v3 with zend-mvc"
        },
        {
            "location": "/migration/#migrating-configuration",
            "text": "zend-di configuration is now expected in  $config['dependencies']['auto'] ,\nwhere  $config  is your  config  service.  The zend-di config service factory will automatically attempt to migrate legacy\nconfigurations at runtime, which gives you some time to migrate your configs.\nYou can use  Zend\\Di\\LegacyConfig  to help migrating existing configs:  use Zend\\Di\\LegacyConfig;\n\n$migrated = new LegacyConfig($diConfigArray);\n$code = var_export($migrated->toArray(), true);  When the zend-di config service factory is used to create configuration for use\nwith the  AutowireFactory  and/or  DefaultContainer , if it detects the $config['di]  key, it will emit an  E_USER_DEPRECATED  error, pointing to this\ndocumentation. We recommend using the above approach to convert your\nconfiguration to the format recognized by version 3.",
            "title": "Migrating configuration"
        }
    ]
}